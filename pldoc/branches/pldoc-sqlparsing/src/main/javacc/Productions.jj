/**
 * 2006-05-22 - Matthias Hendler - Added parsing of triggers and Global functions/procedures
 *                                 Refactored printing of custom tags into the XML/DOM.
 *                                 Custom tags are language independent. Reserved tags are linked
 *                                 to the documented language like RETURN, PARAM and THROWS.
 */

/**
 * 2006-05-22 - Matthias Hendler - added GlobalBody()
 */
void input() throws org.xml.sax.SAXException : {}
{
  { System.err.println("input: attempting parsing of  \"" + inputPath + "\"" ); }
	// SRT 2011-04-17 This syntax breaks the parser when fields of record.attach* are referenced (attachLibrary())*
	(
        //    (LOOKAHEAD(6) PackageSpec() | LOOKAHEAD(6) PackageBody() | LOOKAHEAD(6) typeSpec() | LOOKAHEAD(6) typeBody() | LOOKAHEAD(6) ProgramUnit(true) | SqlPlusCommand())
	 // SRT 20110514 before (LOOKAHEAD(6) PackageSpec() | LOOKAHEAD(6) PackageBody() | LOOKAHEAD(6) typeSpec() | LOOKAHEAD(6) typeBody() | LOOKAHEAD(6) table() | LOOKAHEAD(6) view()  | Global() | SqlPlusCommand())	("/")*
	 ( LOOKAHEAD(8) JavaSpec()  
	 | LOOKAHEAD(7) PackageSpec()  
	 | LOOKAHEAD(7) PackageBody()  
	 | LOOKAHEAD(6) typeSpec()  
	 //| LOOKAHEAD(6) typeBody()  {system.err.println("typeSpec"); }
	 | LOOKAHEAD(6) table()  
	 | LOOKAHEAD(6) view()   
	 | LOOKAHEAD(6) triggerUnit()  
	 | LOOKAHEAD(6) alterTrigger()  
	 | LOOKAHEAD(6) Synonym()   
	 | LOOKAHEAD(6) Directory()   
	 | LOOKAHEAD(6) DatabaseLink()   
	 | LOOKAHEAD(6) Global()  
	 | LOOKAHEAD(4) ProgramUnit(true,null) 
	 | LOOKAHEAD(6) DDLCommand()   
	 | LOOKAHEAD(6) SqlPlusCommand() 
	 |(<SELECT>|<UPDATE>|<INSERT>|<DELETE>|<COMMIT>|<ROLLBACK>|<SAVEPOINT>|<LOCK><TABLE>|<MERGE>|<WITH>|<DECLARE>|<BEGIN>) skipPastNextTokenOccurrence(SQLPLUS_TERMINATOR) //Ignore Sql Statements in scripts
	 )	
	 ("/")*
	)*
	<EOF>
  { System.err.println("input: completed parsing of  \"" + inputPath + "\"" ); }
}

JAVACODE
/** Return the contents of paired parantheses.
 *<p>This does not consume the parantheses. 
 *
 *@param start location at or before the first parantheses. 
 *
 *@return string contents
 */
String parenthesesContents(Token start) 
{
	Token t = start;
	StringBuffer sb = new StringBuffer() ;
	int nesting = 0;
	{System.err.println("parenthesesContents: checking paranthesed text \"(\" and \")\" "
			    + " from "+start.beginLine+", column "+start.beginColumn+" - \""+start.image+"\" "
			    + "at "+t.beginLine+", column "+t.beginColumn+" - \""+t.image+"\" "
			    + "with current Token at "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "
                           ); 
        }
	while (true)
	{
		if (t.kind == 0) //PLSQLParserConstants.EOF
		{
		  throw new ParseException("Parenthesed text error in " + inputPath 
					    + " from "+start.beginLine+", column "+start.beginColumn+" - \""+start.image+"\" "
					    + "to "+t.beginLine+", column "+t.beginColumn+" - \""+t.image+"\" "
					  );
		}

		sb.append(t.image); 
		if (LPAREN == t.kind )
		{
			nesting++;
  {System.err.println("parenthesesContents: incremented nesting to " + nesting + " at line "+t.beginLine+", column "+t.beginColumn+" - \""+t.image+"\" "); }
		}
		else if (RPAREN == t.kind ) 
		{
			nesting--;
  {System.err.println("parenthesesContents: decremented " + nesting + " at line "+t.beginLine+", column "+t.beginColumn+" - \""+t.image+"\" "); }
			if ( 0 == nesting )
			{
  {System.err.println("parenthesesContents: finished " + nesting + " at line "+t.beginLine+", column "+t.beginColumn+" - \""+t.image+"\" "); }
				t = getNextToken();
				break;
			}
		}
                //*
		else
		{
  {System.err.println("parenthesesContents: nochange with nesting  " + nesting + " at line "+t.beginLine+", column "+t.beginColumn+" - \""+t.image+"\" "); }
		}
                //*/


		if (t.beginLine < token.beginLine
                    || (t.beginLine == token.beginLine 
                        && t.beginColumn <= token.beginColumn 
                       ) 
                   ) 
                {
		  t = t.next;
                }
		else
                {
		  t = getNextToken();
		  t = getToken(1); //Next token 
                }

	}
	
  {System.err.println("parenthesesContents: completed at line "+t.beginLine+", column "+t.beginColumn+" - \""+t.image+"\" "); }
  return sb.toString(); 
}


void DDLCommand() : 
{ 
}
{
  (
    DDLEvent()
    skipPastNextTokenOccurrence(SQLPLUS_TERMINATOR) 
  )
}


void SqlPlusCommand() : {}
{
  // e.g. SHOW ERRORS, GRANT EXECUTE ON ... TO ...
  // SqlPLUS commands
  ( "@" 
  | <ACCEPT>
  | <COLUMN>
  | <CONNECT>
  | <COPY>
  | <DEFINE>
  | <DISCONNECT>
  | <EXECUTE> 
  | <EXIT> 
  | <HOST> 
  | <PRINT> 
  | <PROMPT> 
  | <QUIT> 
  | <REMARK> 
  | <SET> 
  | <SHOW> 
  | <SPOOL> 
  | <START> 
  | <UNDEFINE> 
  | <VARIABLE> 
  | <WHENEVER> 
  // DDL that might be encountered
  | <COMMENT>
  | <GRANT>
  | <REVOKE>
  | <DROP>
  | <IDENTIFIER>
  // Attach Library 
  | "." <ATTACH>
  )
  skip2NextTokenOccurrence(EOL) //Tracker Issue 1433480 skip until next EOL Special Token   
  //[";" | "-"]
}

/*
SRT 2011-04-17 This syntax breaks the parser when fields of record.attach* are referenced  in PL/SQL 
void AttachLibrary() :
{}
{
	<".attach"> <IDENTIFIER> <IDENTIFIER> <END> <IDENTIFIER>
}
*/

/**
 * All Global definitions of triggers, functions and procedures are evaluated here.
 * Every occurence goes under a new PACKAGE-Node in the XML document.
 * This happens, cause a Global "block" does not have a definied start and end token 
 * like a package specification or a package body.
 * Thats why every construct is handled like a new part of the Global package.
 * To overcome this problem, I could use an infinity lookahead - which should solve the problem 
 * and slow down the whole parsing.
 * Another idea would be to lookahead the next tokens and decide wether they belong to a package definition or not.
 * Then I could decide to stay in this Global parsing state. By now lookahead gives the parser a hint to
 * choose the correct way on a given base. So we can't negate it easily.
 * On the other hand I could also hold the Global state in a Global variable. 
 * But this does not seems the correct way to solve the problem, I think.
 *
 * 2006-05-17 - Matthias Hendler - added
 */
void Global() throws SAXException :
{ 
	Token name = null; 
}
{
  {System.err.println("Global: attempting Global() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\"  - this is just before token \""+ getToken(1).image +"\"" ); }
	{
		if (m_out != null)
		{
			// now start printing the package
			m_out.pushAttribute("NAME", purifyIdentifier(GlobalPackageName));
			m_out.pushAttribute("SCHEMA", purifyIdentifier(schemaName));
			// System.err.println("startElement @ Global() " );
			m_out.startElement("PACKAGE");
		}
	}

	//SRT Work In progress (LOOKAHEAD ([<DECLARE> DeclarativeSection(false)] <BEGIN>) GlobalBlock() | LOOKAHEAD (4) ProgramUnit(true) // | triggerUnit()
	/*
	  Remove triggers from Global processing because their schema may be defined in the trigger code itself
	  Still wrap the trigger in a fake package but make the package name dependent on the actual schema 
	  defaulting to the GlobalPackageName if it cannot be found 
	*/
	(
  {System.err.println("Global: attempting GlobalBlock() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\"  - this is just before token \""+ getToken(1).image +"\"" ); }
	GlobalBlock(token) 
	//LOOKAHEAD ( ( Label() )* [<DECLARE> DeclarativeSection(false,token)] <BEGIN>) GlobalBlock(token) // | LOOKAHEAD (4) ProgramUnit(true,token) 
  {System.err.println("Global: completed GlobalBlock() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\"  - this is just before token \""+ getToken(1).image +"\"" ); }
	)

	{
		if (m_out != null)
		{
			// System.err.println("endElement @ Global() " );
			m_out.endElement("PACKAGE");
		}
	}

}



/**
 * Static blocks like package initializers.
 * 
 * 2006-05-17 - Matthias Hendler - added
 */
void GlobalBlock(Token objectStart) throws SAXException :
{ 
	Token name = null; 
}
{
	(
		Label()
	)*
	[
		<DECLARE>
		DeclarativeSection(false, objectStart)
	]
	
	<BEGIN> (Statement())* (ExceptionHandler())? <END> [<IDENTIFIER>] ";"
}



void JavaSpec() throws SAXException :
{ ASTCompilationUnit javaCompilationUnit = null ;
  Token schema = null, name = null, tokenCreate = null, tokenPackage = null, tokenJavaType = null, tokenIsAs = null, lastToken = null ; 
}
{
    
	[tokenCreate=<CREATE> [<OR> <REPLACE>] [ <AND> ( <COMPILE> | <RESOLVE> )  ] ]
	tokenPackage=<JAVA> 
    (
      ( ( tokenJavaType = <SOURCE> | tokenJavaType = <RESOURCE> )  <NAMED> (LOOKAHEAD(2) schema=ID()".")? name=ID() )
      |
      ( tokenJavaType = <CLASS> [ <SCHEMA> schema=ID() ] )
    )
	{
		if (m_out != null)
		{
			String schemaString = schemaName; //SRT 20110318 "";
			if (schema != null) {
				schemaString = schema.toString();
			}
			// now start printing the package
			m_out.pushAttribute("NAME", purifyIdentifier( (null==name) ? "Unnamed" : name.toString()));
			m_out.pushAttribute("SCHEMA", purifyIdentifier(schemaString.toString()));
			m_out.pushAttribute("TYPE", purifyIdentifier(tokenJavaType.toString()));
			m_out.startElement("JAVA");
		}
		// possibly, package comment is here
		if(null!= tokenCreate)
		{
			processPackageComment(tokenCreate);
		}
// 		System.err.println("processPackageComment @ PackageSpec() " );
		processPackageComment(tokenPackage);
	}

	(tokenIsAs=<AUTHID> (<CURRENT_USER> | <DEFINER>))?
	{
		// possibly, package comment is here
		processPackageComment(tokenIsAs);
	}

	(tokenIsAs=<ACCESSIBLE> <BY>  <LPAREN> [ <FUNCTION> | <PROCEDURE> | <PACKAGE> | <TRIGGER> | <TYPE> ] QualifiedName()  
                                          ("," [ <FUNCTION> | <PROCEDURE> | <PACKAGE> | <TRIGGER> | <TYPE> ] QualifiedName() )*  
                                      <RPAREN> 
        )
	{
		// possibly, package comment is here
		processPackageComment(tokenIsAs);
	}

	(tokenIsAs=<RESOLVER> <LPAREN>  ( <LPAREN>  ( <MULT> | <QUOTED_LITERAL> )  [","] ( "-" | UnqualifiedID()  )  <RPAREN>  )+    <RPAREN>    )?
	{
		// possibly, package comment is here
		processPackageComment(tokenIsAs);
	}

   (
	  (
	    (tokenIsAs=<USING>)
	    {
		    // possibly, package comment is here
		    processPackageComment(tokenIsAs);
	    }


        (
           LOOKAHEAD(<BFILE> <LPAREN>)  ( <BFILE>  <LPAREN> UnqualifiedID() "," StringLiteral()  <RPAREN> )
          | LOOKAHEAD( ( <CLOB> | <BLOB> | <BFILE> ) <SELECT> ) ( ( <CLOB> | <BLOB> | <BFILE> ) SqlStatement(null,";") [";"] )
          | StringLiteral()
        )
	  )
      |
      (
	    (tokenIsAs=<IS> | tokenIsAs=<AS>)
	    {
		    // possibly, package comment is here
		    processPackageComment(tokenIsAs);
	    }


	    //Populate javaCompilationUnit with productions returned from the wrapped PMD Java parser (also JavaCC generated)
	    { 
           javaCompilationUnit = fromDelegatedJavaParser(); 
        }
	  )
	)
	{ 
		if (m_out != null) m_out.endElement("JAVA"); 
	}
}


void PackageSpec() throws SAXException :
{ Token schema = null, name = null, tokenCreate = null, tokenPackage = null, tokenIsAs = null, lastToken = null ; }
{
	[tokenCreate=<CREATE> [<OR> <REPLACE>] [ <EDITIONABLE> | <NONEDITIONABLE> ] ]
	tokenPackage=<PACKAGE> (LOOKAHEAD(2) schema=ID()".")? name=ID()
	{
		if (m_out != null)
		{
			String schemaString = schemaName; //SRT 20110318 "";
			if (schema != null) {
				schemaString = schema.toString();
			}
			// now start printing the package
			m_out.pushAttribute("NAME", purifyIdentifier(name.toString()));
			m_out.pushAttribute("SCHEMA", purifyIdentifier(schemaString.toString()));
			// System.err.println("startElement @ PackageSpec() " );
			m_out.startElement("PACKAGE");
		}
		// possibly, package comment is here
		if(null!= tokenCreate)
		{
			processPackageComment(tokenCreate);
		}
// 		System.err.println("processPackageComment @ PackageSpec() " );
		processPackageComment(tokenPackage);
	}

	(tokenIsAs=<AUTHID> (<CURRENT_USER> | <DEFINER>))?
	{
		// possibly, package comment is here
		processPackageComment(tokenIsAs);
	}

        [
	(tokenIsAs=<ACCESSIBLE> <BY>  <LPAREN> [ <FUNCTION> | <PROCEDURE> | <PACKAGE> | <TRIGGER> | <TYPE> ] QualifiedName()  
                                         ("," [ <FUNCTION> | <PROCEDURE> | <PACKAGE> | <TRIGGER> | <TYPE> ] QualifiedName() )*  
                                      <RPAREN> 
        )
	{
		// possibly, package comment is here
		processPackageComment(tokenIsAs);
	}
	]

        (
	  (
	    WrappedObject()
	  )
	  |
	  (
	    (tokenIsAs=<IS> | tokenIsAs=<AS>)
	    {
		    // possibly, package comment is here
		    processPackageComment(tokenIsAs);
	    }

	    DeclarativeSection(true,name)

	    <END> [ID()] ";" { printSummary("Package Specification", name.beginLine, name, token); }
	  )
	)
	{ 
		if (m_out != null) m_out.endElement("PACKAGE"); 
	}
}

void PackageBody() throws SAXException :
{ Token schema = null, name = null, tokenCreate = null, tokenModuleType = null, tokenIsAs = null; }
{
	[tokenCreate=<CREATE> [<OR> <REPLACE>]  [ <EDITIONABLE> | <NONEDITIONABLE> ]  ]
	( tokenModuleType = <PACKAGE> | tokenModuleType = <TYPE> ) <BODY> (LOOKAHEAD(2) schema=ID()".")? name=ID()
	{
		if (m_out != null)
		{
			String schemaString = schemaName; //SRT 20110318 "";
			if (schema != null) {
				schemaString = schema.toString();
			}
			// now start printing the package
			m_out.pushAttribute("NAME", purifyIdentifier(name.toString()));
			m_out.pushAttribute("SCHEMA", purifyIdentifier(schemaString.toString()));
			m_out.startElement(
					    tokenModuleType.image.toUpperCase().equals("PACKAGE")
			                    ?  "PACKAGE_BODY"
			                    :  "OBJECT_BODY"
			                  );
		}
		// possibly, package comment is here
		if(null!= tokenCreate)
		{
			processPackageComment(tokenCreate);
		}
		processPackageComment(tokenModuleType);
	}

	(
	  (
	    WrappedObject()
	  )
	  |
	  (
	    (tokenIsAs=<IS> | tokenIsAs=<AS>)
	    {
		    // possibly, package comment is here
		    processPackageComment(tokenIsAs);
	    }

		  DeclarativeSection(true,name) //SRT 20110524 Allow PLDOc in Type Bodies 

						    
	  [ <BEGIN> (Statement())* (ExceptionHandler())? ] <END> [ID()] ";" 
	  { printSummary(tokenModuleType.image.toUpperCase().equals("PACKAGE") ?  "Package Body" :  "Object Type Body", name.beginLine, name, token); }
	  )
	)
	{
		if (m_out != null) m_out.endElement(
						    tokenModuleType.image.toUpperCase().equals("PACKAGE")
						    ?  "PACKAGE_BODY"
						    :  "OBJECT_BODY"
						   );
	}
}

void DeclarativeUnit(boolean isPackageLevel, Token objectStart) throws SAXException :
{}
{
		Pragma(isPackageLevel) |
		LOOKAHEAD(2)
		ExceptionDeclaration(isPackageLevel) |
		LOOKAHEAD((<TYPE>|<SUBTYPE>) QualifiedID() (<IS> | <AS> )  ) //SRT 20110616 - make sue soen't break object type
		SubtypeDefinition(isPackageLevel) |
		LOOKAHEAD((<FUNCTION>|<PROCEDURE>) QualifiedID() ) //SRT 20111117 - Special case of parameterless methods:choose method in preference to variable 
		ProgramUnit(isPackageLevel,objectStart)  |
		LOOKAHEAD(4)
		VariableOrConstantDeclaration(isPackageLevel) |
		LOOKAHEAD(2)
		CursorSpec(isPackageLevel) |
		CursorBody(isPackageLevel) |
		CollectionDeclaration(isPackageLevel) |
		ProgramUnit(isPackageLevel,objectStart) 
		|TypeMethod(isPackageLevel,1, null,objectStart) //SRT 20110523
		|CompilationDeclarationFragment(isPackageLevel,objectStart) 
}

void DeclarativeSection(boolean isPackageLevel, Token objectStart) throws SAXException :
{}
{
	(
		DeclarativeUnit(isPackageLevel, objectStart) 
	)*
}

void CompilationDeclarationFragment(boolean isPackageLevel, Token objectStart) throws SAXException :
{ 
}
{
	( //SRT 20110601 
	  <CC_IF>  
	  ConditionalOrExpression()  
	  <CC_THEN>  
	    (DeclarativeUnit(isPackageLevel,objectStart)
	     | <CC_ERROR> Expression() <CC_END> 
	    )* 

	  ( 
	    <CC_ELSIF> 
	    ConditionalOrExpression() 
	    <CC_THEN> 
	    (DeclarativeUnit(isPackageLevel,objectStart)
	     | <CC_ERROR> Expression() <CC_END> 
	    )* 
	  )* 

	  ( 
	    <CC_ELSE> 
	    (DeclarativeUnit(isPackageLevel,objectStart)
	     | <CC_ERROR> Expression() <CC_END> 
	    )* 
	  )*
	  <CC_END> 
	)
 { 
   return ;
 }
}



/**
 * 2006-05-22 - Matthias Hendler - Printing of custom tag "@deprecated" removed.
 *                                 Printing of any custom tag added. Now user can define his own
 *								   custom tags which he can evaluate in the XSLT.
 *                                 This methode also documents Global functions/procedures.
 */
void ProgramUnit(boolean isPackageLevel, Token objectStart) throws SAXException :
{
	Token start, name;
	Token schema = null;
	Token GlobalStart = null;
	Token startToken = null;
	Token tokenODCIAggregateType = null; 
	Token tokenIsAs = null; 
	String memberName = null;
	String type = null;
	Hashtable tags;
}
{
	(

	[GlobalStart=<CREATE> [<OR> <REPLACE>] [ <EDITIONABLE> | <NONEDITIONABLE> ] 
         
        ]

	(start=<FUNCTION>|start=<PROCEDURE>) (LOOKAHEAD(2) schema = ID()".")? name=ID()
	{
// 		System.err.println("ProgramUnit: isPackageLevel==" + isPackageLevel);
		// element generated only on the package level
		if (m_out != null && isPackageLevel) {

			//This is actually a Global object 
			if (null== objectStart)
			{
			  String packageString = GlobalPackageName; // Default Global Package Name 
			  String schemaString = schemaName; // Default Schema 


			  // Attempt to base 
			  if (null != schema )
			  {
			    schemaString = schema.toString();
			    packageString = ("_" + schemaString ) ; //Base Global package name on Schema
			  }

			  m_out.pushAttribute("NAME", purifyIdentifier(packageString));
			  m_out.pushAttribute("SCHEMA", purifyIdentifier(schemaString));
			  m_out.startElement("PACKAGE");
			}


			memberName = purifyKeyword(start.toString()); // SRT 20110420 --start.toString().toUpperCase();
			/*
			startToken = (GlobalStart == null) ? start : GlobalStart;
			System.err.println("ProgramUnit: calling processMemberComment @ " + startToken.toString());
			tags = processMemberComment(startToken, memberName, name.toString());
			*/
			if (GlobalStart == null) 
			{ // Look for Package Comments and member comments before the start keyword
				//SRT 20110422 System.err.println("ProgramUnit:  no CREATE OR REPLACE calling processMemberComment @ " + start.toString());
				tags = processMemberComment(start, memberName, name.toString()); 
				//SRT 20110422 System.err.println("ProgramUnit:  no CREATE OR REPLACE calling processMemberComment @ START==" + tags.toString());
				tags.putAll(processMemberComment(name, null, null)); // Should find stuff in scripts and database code
				//SRT 20110422 System.err.println("ProgramUnit:  no CREATE OR REPLACE calling processMemberComment @ NAME==" + tags.toString());
			}
			else
			{ // Look for Package Comments and member comments before the CREATE OR REPLACE, then the start keyword
				//SRT 20110422 System.err.println("ProgramUnit:  CREATE OR REPLACE calling processMemberComment GLOBAlSTART " + GlobalStart.toString());
				tags = processMemberComment(GlobalStart, memberName, name.toString()); // Should find stuff in scripts only
				//SRT 20110422 System.err.println("ProgramUnit:  CREATE OR REPLACE calling processMemberComment @ GLOBALSTART==" + start.toString());
				tags.putAll(processMemberComment(start, null, null)); // Should find stuff in scripts and database code
				//SRT 20110422 System.err.println("ProgramUnit:  CREATE OR REPLACE calling processMemberComment @ START==" + tags.toString());
				tags.putAll(processMemberComment(name, null, null)); // Should find stuff in scripts and database code
				//SRT 20110422 System.err.println("ProgramUnit:  CREATE OR REPLACE calling processMemberComment @ NAME==" + name.toString());
			}
		} else {
			tags = new Hashtable();
		}
	}

	( 
	( WrappedObject() ) 
	|//UnwrappedCode
	( (<LPAREN>) {
	          /*
	           Last chance to collect member comment before hitting the parameters
		   Using DBMS_METADATA.GET_DDL here (between the name and the parameter start is the only 
		   place to put a comment that contains parameter/return tags.

		   This is because even if the comment occurs before the object name in the original source code,
		   e.g. <OBJECT TYPE> <COMMENT> <QUALIFIED OBJECT NAME>, 
		   DBMS_METADATA.GET_DDL returns the code in the form <OBJECT TYPE> <QUALIFIED OBJECT NAME> <COMMENT>
		 */
	          tags.putAll(processMemberComment(token, null, null));
	        } 
	  ParameterDeclaration(tags,isPackageLevel) ( "," ParameterDeclaration(tags,isPackageLevel) )* <RPAREN> )*
	{
		//SRT 20110422 System.err.println("ProgramUnit: found ParameterDeclaration" );
	}

	[(<RETURN>){
	          /*
	           Last chance to collect member comment (and the return tag) before hitting the RETURN Statement
		 */
	          tags.putAll(processMemberComment(token, null, null));
	        }  
	 type=datatype()
	{
		//SRT 20110422 System.err.println("ProgramUnit:  RETURN FOUND matching tags in tags=" + tags.toString());
		// element generated only on the package level
		if (m_out != null && isPackageLevel) 
		{
			// @return
			String returnComment = null;
			Collection tagValues = (Collection) tags.get("@return");
			if (tagValues != null) 
			{
				for(Iterator it = tagValues.iterator(); it.hasNext(); )
					returnComment = (String) it.next();
			}
			m_out.pushAttribute("TYPE", purifyIdentifier(type.toString()));
			m_out.startElement("RETURN");
			if (returnComment != null) 
			{
				m_out.startElement("COMMENT");
				m_out.cdata(returnComment);
				m_out.endElement("COMMENT");
			}
			m_out.endElement("RETURN");
		}
	}
	]
	{
		// element generated only on the package level
		if (m_out != null && isPackageLevel)
		{
			// @throws
			String throwsComment = null;
			String exceptionName = null;
			Collection tagValues = (Collection) tags.get("@throws");
			if (tagValues != null)
			{
				Iterator it = tagValues.iterator();
				while(it.hasNext()) {
					throwsComment = (String) it.next();
					// extract when first word - it's the exception name
					StringTokenizer st = new StringTokenizer(throwsComment);
					if (st.hasMoreTokens())
						 exceptionName = st.nextToken();
					if (exceptionName != null)
					{
						m_out.pushAttribute("NAME", purifyIdentifier(exceptionName));
						m_out.startElement("THROWS");
						if (throwsComment != null)
						{
							m_out.startElement("COMMENT");
							m_out.cdata(throwsComment.substring(exceptionName.length()));
							m_out.endElement("COMMENT");
						}
						m_out.endElement("THROWS");
					}
				}
			}
		//SRT 20110422 System.err.println("ProgramUnit: THROW Processing" );
		}
		
		// now print all custom tags
		if (m_out != null && isPackageLevel)
		{
			//SRT 20110422 System.err.println("ProgramUnit:  pre printCustomTags is tags " + tags.toString());
			printCustomTags(tags);
		}
	}

	/*
	//SRT 20110516  Cope with AUTHID  for schema level functions and procedures 
	(tokenIsAs=<AUTHID> (<CURRENT_USER> | <DEFINER>))?
	{
		// possibly, package comment is here
		if (m_out != null && isPackageLevel)
		{
			if (memberName.toUpperCase().equals("PACKAGE"))
			{
				processPackageComment(tokenIsAs);
			}
			else 
			{
			/*
			  We are looking to process any comment only; the member is being dealt with elsewhere
			* /
			tags.putAll(processMemberComment(tokenIsAs, null, null /* memberName, name.toString() * /));
			}
		}	
	}
	*/

	( (<AUTHID> ( <CURRENT_USER> | <DEFINER> ) ) 
	    | (<ACCESSIBLE> <BY>  <LPAREN> 
                                    [ <FUNCTION> | <PROCEDURE> | <PACKAGE> | <TRIGGER> | <TYPE> ] QualifiedName()  
                                   ("," [ <FUNCTION> | <PROCEDURE> | <PACKAGE> | <TRIGGER> | <TYPE> ] QualifiedName() )*  
                                  <RPAREN> 
              )

            | <DETERMINISTIC> 
	    | <PARALLEL_ENABLE>  [ ParallelClause() ] [ <USING> ID() ["." ID()] ] 
	   | <PIPELINED> [ ( <USING> ID() ["." ID()] ) 
	                   |  //20110531
			   (( <ORDER> | <CLUSTER> ) [ID()] <BY> <LPAREN> ID() ( "," ID() )*  <RPAREN> ) 
			 ] //  drvparx.IndexMapDocuments
	   | <RESULT_CACHE> [ <RELIES_ON> <LPAREN> ID() ["." ID()] ( "," ID() ["." ID()])*  <RPAREN> ]
           | CompilationExpression() // Allow Conditional PRAGMA
	) *
	
	[ <AGGREGATE> <USING> tokenODCIAggregateType=ID() ] 

	// body
	[
	        
		(tokenIsAs=<IS> | tokenIsAs=<AS>)
		{
			//SRT 20110422 System.err.println("tokenIsAs @ " + tokenIsAs.toString());
			if (m_out != null && isPackageLevel)
			{
				if (memberName.toUpperCase().equals("PACKAGE"))
				{
					//SRT 20110422 System.err.println("calling processPackageComment @ " + tokenIsAs.toString() );
					processPackageComment(tokenIsAs);
				}
				else 
				{
				//Look for memberComment embedded in the code 
				//SRT 20110422 System.err.println("calling processMemberComment @ " + tokenIsAs.toString()
				//SRT 20110422                    + ",memberName=" + memberName
				//SRT 20110422                    + "name=" + name.toString()
				//SRT		  );
				/*
				  We are looking to process any comment only; the member is being dealt with elsewhere
				*/
				tags = processMemberComment(tokenIsAs, null, null /* memberName, name.toString() */);
				//SRT 20110422 System.err.println("called processMemberComment @ " + tokenIsAs.toString()
				//SRT 20110422                    + ",memberName=" + memberName
				//SRT 20110422                    + "name=" + name.toString()
				//SRT 20110422   );
				}
			}	
		}
		//SRT (<IS> | <AS>)
		(
			LOOKAHEAD(2)
			CallSpecTail(isPackageLevel) //{ System.err.println("Found CallSpecTail") ; }
			|
			(
				DeclarativeSection(false,objectStart)
				<BEGIN> (Statement())* (ExceptionHandler())? <END> [ID()]
			)
		)
	]
	";" //SRT 20110416 { System.err.println("Found terminating semi-colon") ; }
        {
	   //Do not generate Summaries for interanl ProgramUnits that are not output 
           if (isPackageLevel) printSummary("Program Unit", (isPackageLevel && (null != objectStart) ? objectStart.beginLine : name.beginLine), name, token);
        }

	) //UnwrappedCode
	) 
	{
		// element generated only on the package level
		if (m_out != null && isPackageLevel)
		{
// 			System.err.println("endElement@ " + start.toString());
			m_out.endElement(purifyKeyword(start.toString())); // SRT20110420 m_out.endElement(purifyIdentifier(start.toString().toUpperCase()))
			//This is actually a Global object 
			if (null== objectStart)
			{
			  m_out.endElement(purifyKeyword("PACKAGE")); //Wrap the trigger element in a fake package
			}
		}
	}
}

void ParameterDeclaration(Hashtable tags,boolean isPackageLevel) throws SAXException :
{
	Token name;
	Token parameterType = null;
	String defaultValue = null;
	String paramMode = "IN", paramType;
}
{
	name=ID()
	// the order of outer "|" is important !
	( LOOKAHEAD(2) ( LOOKAHEAD(2) ( (<OUT>{paramMode = "OUT";}|(<IN> <OUT>{paramMode = "IN OUT";})) (LOOKAHEAD(2) <NOCOPY> {paramMode += " NOCOPY" ; } )? ) | <IN> ) )?
	(parameterType = "..."    /* PL/SQL VARARG */ { paramType = "..." ; }| paramType=datatype())  { parameterType = token;}
	( (":" "="|<_DEFAULT>) defaultValue =Expression() )?
	{

		if (m_out != null && isPackageLevel)
		{
			String paramName = name.toString();
			String paramComment = getParamComment(paramName, tags);
			m_out.pushAttribute("NAME", purifyIdentifier(paramName));
			m_out.pushAttribute("MODE", paramMode);
			m_out.pushAttribute("TYPE", purifyIdentifier(paramType));
			if (null != defaultValue) m_out.pushAttribute("DEFAULT", purifyIdentifier(defaultValue));
			m_out.startElement("ARGUMENT");
			if (paramComment != null) {
				m_out.startElement("COMMENT");
				m_out.cdata(paramComment);
				m_out.endElement("COMMENT");
			}
			m_out.endElement("ARGUMENT");
		}
	}
}




String datatype() :
{ String name = null, dblink = null ; }
{
	(
		// this should be first
		name = CompilationDataType() |
		LOOKAHEAD(2) name=scalar_datatype_name()
		|
		(
		  ( [LOOKAHEAD(2) <REF>] name=QualifiedName() 
		    //Bug 35352414 - datatype may include dblink 
		    ["@" dblink = QualifiedName() {name += "@" + dblink ;} ]
		    ["%" (<TYPE>{name += "%TYPE";}|<ROWTYPE>{name += "%ROWTYPE";})] )
		)
	)
	{ return name; }
}

String CompilationDataType() :
{ 
  String string = null; 
  StringBuffer sb = new StringBuffer() ;
}
{
	(
	  <CC_IF> {sb.append(" "); sb.append(token.image) ; } 
	  string= ConditionalOrExpression() {sb.append(" "); sb.append(string); } 
	  <CC_THEN> {sb.append(" "); sb.append(token.image); } 
	  string = datatype() {sb.append(" "); sb.append(string); } 

	  ( 
	    <CC_ELSIF> {sb.append(" "); sb.append(token.image); } 
	    string = ConditionalOrExpression() {sb.append(" "); sb.append(string); }  
	    <CC_THEN> {sb.append(" "); sb.append(token.image); } 
	    string = datatype() {sb.append(" "); sb.append(string); } 
	  )* 

	  ( 
	    <CC_ELSE> {sb.append(" "); sb.append(token.image); } 
	    string = datatype()  {sb.append(" "); sb.append(string); } 
	  )*

	  <CC_END> {sb.append(" "); sb.append(token.image); } 
	)
 { 
 return sb.toString(); 
 }
}

String collection_type_name() :
{ Token size=null, precision=null;
	String name = null;
}
{
     (
	// Collection types
  	<TABLE> | <VARRAY> | (<VARYING><ARRAY> {name = "VARYING ARRAY";}) 
     )

    {
      if (name == null) {
        name = token.toString();
      }
    }
	(LOOKAHEAD(2) <LPAREN> size=NumericLiteral() {name += "(" + size;}
		["," precision=NumericLiteral() {name += "," + precision;}]
		[ <CHAR> {name += " CHAR" ;}]
		[ <BYTE> {name += " BYTE" ;}]
	<RPAREN> {name += ")" ;})?

      { return name; }
}


String scalar_datatype_name() :
{ Token size=null, precision=null ;
	String name = null, precisionString=null ;
	String string = null;
}
{
	(
	//Base types used in SYS.STANDARD
	<BFILE_BASE> |
	<BLOB_BASE> |
	<CHAR_BASE> |
	<CLOB_BASE> |
	<DATE_BASE> |
	<NUMBER_BASE> | 

	// scalar types - numeric:
  	<BINARY_INTEGER> | <DEC> | <DECIMAL> | (<DOUBLE><PRECISION> {name = "DOUBLE PRECISION";}) |
  	<FLOAT> | <INT> | <INTEGER> | <NATURAL> |
	<NATURALN> | <NUMBER> | <NUMERIC> | <PLS_INTEGER> | <POSITIVE> | <POSITIVEN> | <REAL> | <SIGNTYPE> |
	<SMALLINT> |

	// scalar types - character:
	(
	  (
	  <CHAR> | <CHARACTER> 
	  //SRT | LOOKAHEAD(2) (<LONG><RAW> {name = "LONG RAW";}) | LOOKAHEAD(2) <LONG> | 
	  | LOOKAHEAD(2) (<LONG><RAW> {name = "LONG RAW";}) | <LONG> | 
	  <NCHAR> | <NVARCHAR2> | <RAW> | <ROWID> |
	  <STRING> | <UROWID> | <VARCHAR> | <VARCHAR2> | <CLOB> | <NCLOB> 
	  )
	)
	|
	  // scalar types - boolean:
	  <BOOLEAN> 
	
	|

	// composite types
  	//SRT 20090531 <TABLE> | <VARRAY> | (<VARYING><ARRAY> {name = "VARYING ARRAY";}) |
	// <RECORD> - defined elsewhere

	// LOB types
	<BFILE> | <BLOB> |

	// reference types
  	<SYS_REFCURSOR> | //SRT Added to support pre-defined weak REF CURSOR
  	(<REF><CURSOR> {name = "REF CURSOR";}) |
	//<REF> object_type - defined elsewhere

	// scalar types - date/time:
	<DATE> |
        LOOKAHEAD(2) (<INTERVAL><YEAR> {name = "INTERVAL YEAR";}) |
        LOOKAHEAD(2) (<INTERVAL><DAY> {name = "INTERVAL DAY";}) |
	<TIME> |
	<TIMESTAMP> |
      (<SELF><AS><RESULT> {name = "SELF AS RESULT";})  //SRT Added to support CONSTRUCTOR methods 
     )

    {
      if (name == null) {
        name = token.toString();
      }
    }
	(LOOKAHEAD(2) <LPAREN> size=NumericLiteral() {name += "(" + size;}
		["," precisionString=UnaryExpression(true) {name += "," + precisionString;}] //NUMBERS may have negative precision
		[ <CHAR> {name += " CHAR" ;}]
		[ <BYTE> {name += " BYTE" ;}]
	<RPAREN> {name += ")" ;})?

        /*
	    LOOKAHEAD(3) (<DAY><TO><SECOND> {name += " DAY TO SECOND";}) |
	    LOOKAHEAD(3) (YEAR><TO><MONTH> {name += " YEAR TO MONTH";}) |
	    LOOKAHEAD(4) (<WITH><LOCAL><TIME><ZONE> {name += " WITH LOCAL TIME ZONE";}) |
	    LOOKAHEAD(3) (<WITH><TIME><ZONE> {name += " WITH TIME ZONE";}) |
            INTERVAL YEAR[(year_precision)] TO MONTH

            INTERVAL DAY[(day_precision)] TO SECOND[(fractional_seconds_precision)]

            INTERVAL '2-6' YEAR TO MONTH
            INTERVAL '3 12:30:06.7' DAY TO SECOND(1)
            
          Add any fractional_seconds_precision
        */
    [
      /*
      function NOOP(Str varchar2 CHARACTER SET ANY_CS)
	       return varchar2 CHARACTER SET Str%CHARSET;

      function NOOP(Str clob CHARACTER SET ANY_CS)
	       return clob CHARACTER SET Str%CHARSET;
      */


    (<CHARACTER> <SET> string = Name() {name += " CHARACTER SET " + string ;} ) |
	  
    LOOKAHEAD(4) (<WITH><LOCAL><TIME><ZONE> {name += " WITH LOCAL TIME ZONE";}) |
    LOOKAHEAD(3) (<WITH><TIME><ZONE> {name += " WITH TIME ZONE";}) |
    LOOKAHEAD(2) (<TO><MONTH> {name += " TO MONTH";}) |
    LOOKAHEAD(2) (<TO><SECOND> {name += " TO SECOND";} 
			(
			  LOOKAHEAD(2) <LPAREN> precision=NumericLiteral() {name += "(" + precision;}
					<RPAREN> {name += ")" ;}
			)?
                 )
   ]

      { return name; }
}

String DateTimeLiteral() :
{ Token literal_type= null, type1=null, type2=null, size=null;
	String literal_string = null;
	StringBuffer sb = new StringBuffer();
}
{
  /*
    INTERVAL Syntax

    INTERVAL'y-m' YEAR[(precision1)] TO MONTH
    INTERVAL'y' YEAR(precision1)
    INTERVAL'm' MONTH(precision1)

    INTERVAL'd[h[:m[:s]]]' unit1[(precision1)] TO unit2[(precision2)]
      unit1,unit2 = {DAY,HOUR,MINUTE,SECOND}
      constraint unit1 always longer than unit2, i.e. DAY is longer than MINUTE
      so can have DAY to MINUTE, but not MINUTE to DAY
  */
	(
        <INTERVAL> 
	|<DATE> //Support ANSI DATE Literals 
	|<TIMESTAMP> 
        )
        { sb.append(token.toString()); }

        (
         // 20110526 <STRING_LITERAL> 
         <CHARACTER_LITERAL> {sb.append(" "); sb.append(token.toString()) ;} 
         |literal_string = StringLiteral() {sb.append(" "); sb.append(literal_string); } 
        )
        (  type1 = <YEAR>  
         | type1 = <MONTH>
         | type1 = <DAY>
         | type1 = <HOUR>
         | type1 = <MINUTE>
         | type1 = <SECOND>
        )?
        { 
	      if (type1 != null) 
              {
		sb.append(" "); sb.append(type1.toString()) ;
	      }
           
        }
        

	(LOOKAHEAD(2) <LPAREN> size=NumericLiteral() {sb.append("("); sb.append(size); } 
	<RPAREN> {sb.append(")"); } 
        )?


    [
     (<WITH> {sb.append(" "); sb.append(token.toString()) ;} 
      (<LOCAL> {sb.append(" "); sb.append(token.toString()) ;} )? 
      <TIME><ZONE> {sb.append(" TIME ZONE"); }
     ) 
    |(<TO> {sb.append(" "); sb.append(token.toString()) ;} 
        (  type2 = <YEAR>  
         | type2 = <MONTH>
         | type2 = <DAY>
         | type2 = <HOUR>
         | type2 = <MINUTE>
         | type2 = <SECOND>
        )
        {sb.append(" "); sb.append(type2.toString()) ;} 
	(LOOKAHEAD(2) <LPAREN> size=NumericLiteral() {sb.append("("); sb.append(size);} 
	<RPAREN> {sb.append(")"); } 
        )?
    )
   ]
/*
*/

      { 
      return sb.toString(); 
      }
}

void ExceptionHandler() throws org.xml.sax.SAXException :
{}
{
	<EXCEPTION>
		( LOOKAHEAD(2) <WHEN> QualifiedName() (<OR> QualifiedName())* <THEN> (Statement())+ )*
		[ <WHEN> <OTHERS> <THEN> (Statement())+ ]
}

void skip2NextTerminator(String initiator,String terminator) :
{
  Token t = getToken(1);
  int count = (initiator == null) ? 0 : 1;
  if(t.image.equals(initiator)) count++;
  System.err.println( "skip2NextTerminator("+initiator+","+terminator+") starting with count=="+count ); 
  while (
         (count > 0 || !t.image.equals(terminator))
	 && t.kind!=EOF 
        )
  {
    t = getNextToken();
    t = getToken(1);
    if(t.image.equals(initiator)) count++;
    if(t.image.equals(terminator)) count--;
    System.err.println( "... \"" + t.image +"\""  ); 
  }
  System.err.println( "skip2NextTerminator count=="+count+ " at line "+t.beginLine+", column "+t.beginColumn+" - \""+t.image+"\" "); 
}
{
	{ return; }
}

/*
 Read Tokens up to but not including the target String. 
*/
void skip2NextOccurrence(String target) :
{
  Token nextToken = getToken(1);
  while (!nextToken.image.equals(target)
	 && (null == nextToken.specialToken || !nextToken.specialToken.image.equals(target) ) //In case the target is a Special Token
	 && nextToken.kind!=EOF //SRT 20110521 - Prevent endless loop when target does not exist in the input stream
        )
  {
    nextToken = getNextToken();
    nextToken = getToken(1);
  }
}
{
	{ return; }
}

/*
 Read Tokens up to and including the target String. 
*/
void skipPastNextOccurrence(String target) :
{
  Token t = null;
  skip2NextOccurrence(target) ;
  t = getNextToken(); // Chomp this one 
}
{
	{ return; }
}

/*
 Read Tokens up to but not including the target Token.kind. 
*/
void skip2NextTokenOccurrence(int target) :
{
  Token nextToken = getToken(1);
  Token specToken = null ;
  while (nextToken.kind!=target
	 && (null == nextToken.specialToken || nextToken.specialToken.kind!=target ) //In case the target is a Special Token
	 && nextToken.kind!=EOF //SRT 20110521 - Prevent endless loop when target does not exist in the input stream
        )
  {
  /*
	Check if the target appears as a SpecialToken 


	nextToken.specialToken points to the _LAST_ of any SpecialTokens before the current normal Token.

	It is the head of a doubly-linked list:

	The ${specialToken}.specialToken field POINTS BACKWARDS TOWARDS the FIRST occurring SpecialToken
	The ${specialToken}.next field POINTS FORWARDS to to the LAST occurring SpecialToken

	This means that if the program is interested in a specific SpecialToken, it must examine the linked list for every Token which has nexToken.specialToken != null.
    
    */
    specToken = nextToken.specialToken;
    if (null!= specToken) 
    {
	    //Walk backwards through the list looking for this Token as a Special Token 
       while (specToken != null && specToken.kind != target) 
	    {
		    specToken = specToken.specialToken;
	    }

	     //We have found the target as a SpecialToken - break out of normal Token search
      if (null != specToken && specToken.kind == target) 
	    {
		    break;
      }
    }

    nextToken = getNextToken();
    nextToken = getToken(1);
  }
}
{
	{ return; }
}

/*
 Read Tokens up to and including the target Token.kind. 
*/
void skipPastNextTokenOccurrence(int target) :
{
  Token t = null;
  skip2NextTokenOccurrence(target) ;
  t = getNextToken(); // Chomp this one 
}
{
	{ return; }
}

/*
 Read Tokens up to but not including the target String. 
*/
String read2NextOccurrence(String target) :
{
  StringBuffer sb = new StringBuffer();
  Token nextToken = getToken(1);
  while (!nextToken.image.equals(target)
	 && nextToken.kind!=EOF 
        )
  {
    nextToken = getNextToken();
    sb.append(nextToken.image);
    nextToken = getToken(1);
  }
}
{
	{ return sb.toString(); }
}

/*
 Read Tokens up to and including the target String. 
*/
String readPastNextOccurrence(String target) :
{
  StringBuffer sb = new StringBuffer();
  Token t = null;
  sb.append(read2NextOccurrence(target)) ;
  t = getNextToken(); // Chomp this one 
  sb.append(t.image);
}
{
	{ return sb.toString(); }
}

/**
 * 2006-05-24 - Matthias Hendler - added MERGE
 */
void SqlStatement(String initiator, String terminator) throws SAXException :
{}
{
	//(<SELECT>|<UPDATE>|<INSERT>|<DELETE>|<COMMIT>|<ROLLBACK>|<SAVEPOINT>|<EXECUTE>|<SET><TRANSACTION>|<LOCK><TABLE>|<MERGE>|<WITH>)
	//  skip2NextTerminator(initiator,terminator)
      try {
    
	  (
	   // <SELECT>|<WITH>
	    SqlSelectStatement() 
	   |//<UPDATE>
	    SqlUpdateStatement()
	   |//<DELETE>
	    SqlDeleteStatement()
	   |//<INSERT>
	    SqlInsertStatement()
	   |//<MERGE>
	    SqlMergeStatement()
	   |//<COMMIT>
	   CommitStatement()
	   |// <ROLLBACK>
	    RollbackStatement()
	   |// <SAVEPOINT>
	    SavepointStatement()
	   |// <EXECUTE>
	    EmbeddedSqlStatement()  
	   |// <SET><TRANSACTION>
	    SetTransactionStatement()
	   |// <LOCK><TABLE>
	    LockTableStatement()
	  )
	}
	catch (ParseException e) {
          System.err.println( "SQL parsing error in " + inputPath ); 
	  e.printStackTrace(System.err);  // print the error message
	  skip2NextTerminator(initiator,terminator);
	}

}

/**
 * Trap paranthesed SELECT query parsing problems, preventing SELECT parsing problems propagating.
 */
void SqlSafeSubquery() :
{
  Token start = token;
  Token t = null;
  String string = null ;
}
{
     { start = getToken(1); }
     {System.err.println("SqlSafeSubquery: attempting SqlSafeSubquery() at line "
                         +token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
     }
      try {
	   { System.err.println( "SQL Subquery parsing attempt in " + inputPath ); }
	   ( <LPAREN> { start = token ; }  SqlSubquery() [ SqlForUpdateClause() ] <RPAREN> )
	   {System.err.println("SqlSafeSubquery: "
				  + "completed SqlSafeSubquery() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\";"
				  + " started SqlSafeSubquery() at line "+start.beginLine+", column "+start.beginColumn+" - \""+start.image+"\" "
				); 
            printDML("SELECT", start, token, tableReferences, null );
	   }
	}
	catch (ParseException e) {
          System.err.println( "SQL Subquery parsing error in " + inputPath ); 
	  e.printStackTrace(System.err);  // print the error message
	  System.err.println("SqlSafeSubquery: recovery starting: "
                             + "rewinding to line "+start.beginLine+", column "+start.beginColumn+" - \""+start.image+"\" "
                             + "; currently at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "
                            ); 
	  string = parenthesesContents(start); 
	  System.err.println("SqlSafeSubquery: recovery completed at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
	  printDML("SELECT", start, token, tableReferences, e );
	}
}



/**
 * 2011-05-15 - SRT - Added to cope with wrapped objects
  A wrapped function looks like this (always terminated by one or more equals signs "="):-
  "  CREATE OR REPLACE FUNCTION "TESTUSER"."GET_DATE_STRING"
/ ** Return SYSDATE formatted using the provided template.
 *
 *
 *  @param p_date_format normal TO_CHARE/TO_DATE date template
 *  @return formatted datestring
 *  @see http://www.oracle-base.com/articles/10g/WrapAndDBMS_DDL_10gR2.php#dbms_ddl
 * /
wrapped
a000000
369
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
8
89 b6
/SBrhM8+1iUO4QAih+qD2SK8kSowg8eZgcfLCNL+XlquYvSuoVah8JbRPpdHDLHn479SdFLw
v04omzJ0zOfHdMAzuHQlw+fAsr2ym9YI8I521pRTbnFVAHOOUw4JqPkIyj7wj4VwyL17nhYb
3qPVuL6SvhZTmEBnRtaErHpzaDuIpqZ0G4s=
  "
 */



void WrappedObject() throws SAXException :
{}
{
	<WRAPPED>
	{
	   Token nextToken; 
		
		nextToken = getToken(1); //ReadAhead
		while (
		     null != nextToken && nextToken.kind!=EOF
		     )  
		{
		        nextToken = getNextToken(); 

			//Execute manual readahead 
			nextToken = getToken(1); //ReadAhead 1 Token 
		}
		return;
	}
}


// ============================================================================
// S T A T E M E N T S
// ============================================================================

/**
 * 2006-05-24 - Matthias Hendler - added MERGE, EXECUTE choice and LOOKAHEAD at <LOOP>
 */
void Statement() throws SAXException :
{}
{
	LOOKAHEAD([<LPAREN>] <SELECT>|<UPDATE>|<INSERT>|<DELETE>|<COMMIT>|<ROLLBACK>|<SAVEPOINT>|<EXECUTE>|<SET><TRANSACTION>|<LOCK><TABLE>|<MERGE>|<WITH>) SqlStatement(null,";") [";"] 
		| LOOKAHEAD(3) <CONTINUE> [ <IDENTIFIER> ] [ <WHEN> Expression() ] ";" // 11G CONTINUE Statement  

		| <CASE> ( Expression() )?
                ( <WHEN> Expression() <THEN> (Statement())+ )*
		( <ELSE> (Statement())+ )*
		<END> <CASE>  [<IDENTIFIER>]  ";"
	| <IF> Expression() <THEN> (Statement())+
		( <ELSIF> Expression() <THEN> (Statement())+ )*
		( <ELSE> (Statement())+ )*
		<END> <IF> ";"
	| <FOR> ID() <IN> 
          ( 
	    //LOOKAHEAD( <LPAREN> (<SELECT>|<WITH>)  ) ( <LPAREN> SqlSafeSubquery() [ SqlForUpdateClause() ] <RPAREN> ) 
	    LOOKAHEAD( <LPAREN> (<SELECT>|<WITH>)  ) ( SqlSafeSubquery() ) 
            | 
            ( [<REVERSE>] Expression()[".."Expression()] ) 
          ) 
          <LOOP> (Statement())+ <END> <LOOP> [<IDENTIFIER>] ";"
	| <FORALL> ID() <IN> 
			    (
	                     ( <INDICES> | <VALUES> ) <OF> Expression() // Add support for sparse collections
	                     | Expression() [".." Expression()]
			    )
			    [ <SAVE> <EXCEPTIONS> ] SqlStatement(null,";") ";"
	| LOOKAHEAD(2) <LOOP> (Statement())+ <END> <LOOP> [<IDENTIFIER>] ";"
	| <WHILE> Expression() <LOOP> (Statement())+ <END> <LOOP> [<IDENTIFIER>] ";"
	//
	| <GOTO> QualifiedName() ";"
	| <RETURN> [Expression()] ";"
	| <EXIT> [<WHEN> Expression() | <IDENTIFIER> [<WHEN> Expression()]] ";"
	| <RAISE> [QualifiedName()] ";"
	//
	| <CLOSE> QualifiedName() ";"
	| <OPEN> [Expression()]
		//[LOOKAHEAD(functionCall()) functionCall() | QualifiedName()]
		[<FOR> Expression() [<USING> Expression() ("," Expression())*]] ";"
	| <FETCH> QualifiedName() [<BULK> <COLLECT>]
	  //MMUE 04/08/2005 <INTO> (LOOKAHEAD(functionCall()) functionCall() | QualifiedName()) ("," (LOOKAHEAD(functionCall()) functionCall() | QualifiedName()))* ";"
	  <INTO> Expression() ("," Expression())* [<LIMIT> Expression()] ";"
	//
	| Label() Statement()
	| [<DECLARE> DeclarativeSection(false,token)] <BEGIN> (Statement())* (ExceptionHandler())? <END> [<IDENTIFIER>] ";"
	//
        | <EXECUTE> <IMMEDIATE> Expression() /* <STRING_LITERAL> */ 
	  [ [ <BULK> <COLLECT> ] <INTO> Name() ("," Name())* ] 
	  [ <USING> [ <IN> [ <OUT> ] | <OUT> ]  Expression() ("," [ <IN> [ <OUT> ] | <OUT> ] Expression())* ] 
	  [ ( <RETURN> | <RETURNING> ) [ <BULK> <COLLECT> ] <INTO> Expression() ("," Expression())* ] 
          ";"

	//SRT 20110429 | <EXECUTE> <IMMEDIATE> StringExpression()  [<USING> Expression() ("," Expression())*] ";"
	// PIPELINED FUNCTION OUTPUT
	| <PIPE> <ROW> Expression()  ";"
	// CONDITIONAL COMPILATION 
	| <CC_IF> ConditionalOrExpression() <CC_THEN> (Statement())*
		( <CC_ELSIF> ConditionalOrExpression() <CC_THEN> (Statement())+ )*
		( <CC_ELSE> (Statement())+ )*
		<CC_END> 
	| <CC_ERROR> Expression() <CC_END> 
        | <PRAGMA> Expression() ";"
        | Expression() ";"
}

void SubtypeDefinition(boolean isPackageLevel) throws SAXException :
{
	Token start, subtype_name=null, constraint=null, base_type=null;
	Token collection = null, collection2 = null;
	Token notNullable = null;
	String startElement = null, endElement = null;
	String baseType = null, returnType = null, indexBy = null, string = null;
	Hashtable tags = null;
	int lastField = 0;
}
{

	(
		( 
		  start=<SUBTYPE> subtype_name=QualifiedID() // SRT 20110605 to Parse SYS.standars ned to allow nprmally reserved words which are low-level types 
			{
				// element generated only on the package level
				if (m_out != null && isPackageLevel) {
					tags = processMemberComment(start, "TYPE", subtype_name.toString());
				}
			}
			<IS> baseType=datatype() 
			{
				returnType = baseType;
			}
			[
			  ( <LPAREN> constraint=<IDENTIFIER> <RPAREN>) // SRT 20110604 [<NOT> <NULL> ]
			  {
				  if (constraint != null) {
					  returnType += "(" + constraint + ")" ;
				  }
			  }
			  |
			  ( constraint = <RANGE> startElement = UnaryExpression(true)  ".." endElement = UnaryExpression(true) ) // In "RANGE -1 .. 31" -1 is a unary Expression
			  {
				  if (constraint != null) {
					  returnType += " RANGE " + startElement + ".." + endElement ;
				  }
			  }
			]

			[<NOT> <NULL> { returnType += " NOT NULL"; } ] //SRT 20110604
		)
		 |
		( start=<TYPE> subtype_name=QualifiedID() // SRT 20110605 to Parse SYS.standars ned to allow nprmally reserved words which are low-level types 
			{
				// element generated only on the package level
				if (m_out != null && isPackageLevel) {
					tags = processMemberComment(start, "TYPE", subtype_name.toString());
				}
			}
			(<IS>|<AS>)
			(
				LOOKAHEAD(2) <NEW> (
				                    base_type = <CHAR_BASE> 
				                    |base_type = <DATE_BASE> 
				                    |base_type = <CLOB_BASE> 
				                    |base_type = <BLOB_BASE> 
				                    |base_type = <BFILE_BASE> 
				                    |base_type = <NUMBER_BASE> 
				                   ) 
				  { returnType = "NEW " + base_type.toString().toUpperCase() ; }
				|
				//SRT 20110606 SYS.STANDRD 
				(<OBJECT> {baseType = "OBJECT";} <LPAREN> FieldDeclaration(isPackageLevel, tags) ("," FieldDeclaration(isPackageLevel, tags))* <RPAREN> )
					{
						returnType = "OBJECT";
						// end for
					}
				|
				(<RECORD> {baseType = "RECORD";} <LPAREN> FieldDeclaration(isPackageLevel, tags) ("," FieldDeclaration(isPackageLevel, tags))* <RPAREN> )
				{
					returnType = "RECORD";
					// end for
				}
				|
				((collection=<TABLE> | collection=<VARRAY> | collection=<VARYING> collection2=<ARRAY>)[<LPAREN> constraint=NumericLiteral() <RPAREN>]
				<OF> baseType=datatype() (notNullable = <NOT> <NULL>)? (<INDEX> <BY> indexBy=datatype())?)
				{
					returnType = collection.toString();
					if (collection2 != null) {
						returnType += " " + collection2;
					}
					if (constraint != null) {
						returnType += "(" + constraint + ")" ;
					}
					returnType += " OF " + baseType;

					if (notNullable != null) {
						returnType += " NOT NULL";
					}

					if (indexBy != null) {
						returnType += " INDEX BY " + indexBy;
					}
				}
				|
				<REF> <CURSOR> [<RETURN> baseType=datatype()]
				{
					returnType = "REF CURSOR";
					if (baseType != null) {
						returnType += " RETURN " + baseType;
					}
				}
				//Enumeration 
				| ( <LPAREN> 
				      string = Expression() {returnType = "(" +  string; } 
				              ( "," string = Expression() {returnType += "," +  string; } )* 
				    <RPAREN> {returnType += ")" ; } 
			          )
				//Alias for existing type  
				| returnType = datatype() 
			)
		)
	)
	";"
	{
		// element generated only at the package level
		if (m_out != null && isPackageLevel)
		{
			if (returnType != null)
			{
				m_out.pushAttribute("TYPE", returnType);
				m_out.element("RETURN");
			}
			m_out.endElement("TYPE");
		}
	}
}

void FieldDeclaration(boolean isPackageLevel, Hashtable tags) throws SAXException :
{
	Token name;
	String dataType;
	String defaultValue = null;
}
{
	name=ID() dataType=datatype() [[<NOT>] <NULL>] [ (":" "=" | <_DEFAULT>) defaultValue = Expression() ]  
	{
		if (m_out != null && isPackageLevel)
		{
			String paramName = name.toString();
			String paramComment = getParamComment(paramName, tags);
			m_out.pushAttribute("NAME", purifyIdentifier(paramName));
			m_out.pushAttribute("TYPE", purifyIdentifier(dataType));
			if (null != defaultValue) m_out.pushAttribute("DEFAULT", purifyIdentifier(defaultValue));
			m_out.startElement("FIELD");
			if (paramComment != null) {
				m_out.startElement("COMMENT");
				m_out.cdata(paramComment);
				m_out.endElement("COMMENT");
			}
			m_out.endElement("FIELD");
		}
	}
}

void CollectionTypeDefinition() : {} { <IDENTIFIER> }
void CollectionDeclaration(boolean isPackageLevel) : {} { <IDENTIFIER> }
void ObjectDeclaration() : {} { <IDENTIFIER> }

/** Java stored procedure, external function*/
void CallSpecTail(boolean isPackageLevel) : {
}
{
	// /* <LANGUAGE> (/*"C"*/<IDENTIFIER> | <JAVA>)

	(
		( <EXTERNAL>
		|<LANGUAGE> (/*"C"*/<IDENTIFIER> | <JAVA>)

		)//SRT 20110516 { System.err.println("Found EXTERNAL or LANG ") ; }
		//These can appear in any order ....
		(
		  ( <LIBRARY> (<IDENTIFIER> | <QUOTED_LITERAL> | StringLiteral() )
			      [ "." (<IDENTIFIER> | <QUOTED_LITERAL> | StringLiteral() )  ]
		  )
		  |
		  ( <NAME> (<IDENTIFIER>  | <QUOTED_LITERAL> /* C */| StringLiteral() /* JAVA */ ) )
		  //SRT 20110517  Need to cope with  CallSpecTails in ObjectTypes  // skip2NextTerminator(null,";") 
		  //skipPastNextOccurrence(<RPAREN>) // Read until we have eaten the closing bracket <RPAREN> 
		  |
		  (
		    <WITH> <CONTEXT>
		  )
		  |
		  (
		    <PARAMETERS>
		    skipPastNextOccurrence(")") // Read until we have eaten the closing bracket <RPAREN> 
		  )
		)*
	)
	{
		return;
	}

	/* ### or:
		<LIBRARY> library_name
		[NAME c_string_literal_name]
		[WITH CONTEXT]
		[PARAMETERS (external_parameter[, external_parameter]...)];

		Where library_name is the name of your alias library, c_string_literal_name is the name of your external C procedure, and external_parameter stands for:

		{
		   CONTEXT
		 | SELF [{TDO | property}]
		 | {parameter_name | RETURN} [property] [BY REFERENCE] [external_datatype]
		 }

		where property stands for:

		{INDICATOR [{STRUCT | TDO}] | LENGTH | MAXLEN | CHARSETID | CHARSETFORM}

		( <INDICATOR> [ <STRUCT> |  <TDO>] |  <LENGTH> |  <MAXLEN> |  <CHARSETID> |  <CHARSETFORM>  )

	*/

  /*
  "
  (
  (<EXTERNAL> |  <LANGUAGE> ( <JAVA> | <IDENTIFIER> )  )
  <NAME> <IDENTIFIER>
  <LIBRARY> <IDENTIFIER>
  [ <WITH> <CONTEXT> ]
  [<PARAMETERS> 
    <LPAREN>
     <CONTEXT> 
     ( ","
             (
	       <SELF> [ <TDO> | [ ( <INDICATOR> [ <STRUCT> |  <TDO>] ) |  <LENGTH> |  <MAXLEN> |  <CHARSETID> |  <CHARSETFORM> ] ]
	     | ( 
	         (<IDENTIFIER> | <RETURN> )  
		 [ <TDO> | [ ( <INDICATOR> [ <STRUCT> |  <TDO>] ) |  <LENGTH> |  <MAXLEN> |  <CHARSETID> |  <CHARSETFORM> ] ]
		 [<BY> <REFERENCE> ]
		 [ <IDENTIFIER> ]
               )
	     )
      )*
     <RPAREN>
  ]
  )
  {
   return;
  }
  */
}






/** Cursor (common part of specification and body) */
void CursorUnit(boolean isPackageLevel) throws SAXException :
{
	Token start, name;
	String type;
	Hashtable tags = new Hashtable();
}
{
	(
	start=<CURSOR> name=ID()
	{
		// element generated only on the package level
		if (m_out != null && isPackageLevel) {
			tags = processMemberComment(start, purifyKeyword(start.toString()), name.toString());
		} else {
			tags = new Hashtable();
		}
	}
	( <LPAREN> ParameterDeclaration(tags,isPackageLevel) ( "," ParameterDeclaration(tags,isPackageLevel) )* <RPAREN> )*
	[<RETURN> type=datatype()
	{
		// element generated only on the package level
		if (m_out != null && isPackageLevel)
		{
			String returnComment = null;
			Collection tagValues = (Collection) tags.get("@return");
			if (tagValues != null)
			{
				Iterator it = tagValues.iterator();
				while (it.hasNext())
					returnComment = (String) it.next();
			}
			m_out.pushAttribute("TYPE", purifyIdentifier(type.toString()));
			m_out.startElement("RETURN");
			if (returnComment != null)
			{
				m_out.startElement("COMMENT");
				m_out.cdata(returnComment);
				m_out.endElement("COMMENT");
			}
			m_out.endElement("RETURN");
		}
	}
	]
	)
	{
		// element generated only on the package level
		if (m_out != null && isPackageLevel) {
			m_out.endElement(purifyKeyword(start.toString()));
		}
	}
	[<IS> SqlSelectStatement()
	{System.err.println("CursorUnit: completed SqlSelectStatement()"); }
        ] ";"
}

void CursorSpec(boolean isPackageLevel) throws SAXException : {}
{
	CursorUnit(isPackageLevel)
}

void CursorBody(boolean isPackageLevel) throws SAXException : {}
{
	CursorUnit(isPackageLevel)
//	<IS> /*<SQL_STATEMENT>*/
}

void EmbeddedSqlStatement()  :
{}
{
   <EXECUTE> <IMMEDIATE> Expression() // StringLiteral() /* <STRING_LITERAL> */ 
	//SRT 20110429 | <EXECUTE> <IMMEDIATE> StringExpression()  [<USING> Expression() ("," Expression())*] ";"
	//SRT 20121126 | <EXECUTE> <IMMEDIATE> StringExpression()  
	[ [ <BULK> <COLLECT> ] <INTO> Name() ("," Name())* ] 
	[ <USING> [ <IN> [ <OUT> ] | <OUT> ]  Expression() ("," [ <IN> [ <OUT> ] | <OUT> ] Expression())* ] 
	[ ( <RETURN> | <RETURNING> )  [ <BULK> <COLLECT> ] <INTO> Expression() ("," Expression())*] ";"
	// PIPELINED FUNCTION OUTPUT
}



// ============================================================================
// E X P R E S S I O N S
// ============================================================================

/*
String expression() :
{}
{
	"test"
	{ return ""; }
}
*/



String Expression() :
{ 
  String string = null; 
  StringBuffer sb = new StringBuffer() ;
}
{
	// Need syntactic lookahead to discriminate between Assignment and a procedure call
	(
  	LOOKAHEAD( PrimaryExpression() ":" "=" ) (string = Assignment()) {sb.append(string);  }  
	| (string = ConditionalOrExpression() )  {sb.append(string); }  
	//| (string = CompilationExpression() )  {sb.append(string); }  //SRT 
	)
 { 
 return sb.toString(); 
 }
}

String CompilationExpression() :
{ 
  String string = null; 
  StringBuffer sb = new StringBuffer() ;
}
{
	(
	  <CC_IF> {sb.append(" "); sb.append(token.image) ; } 
	  string= ConditionalOrExpression() {sb.append(" "); sb.append(string); } 
	  <CC_THEN> {sb.append(" "); sb.append(token.image); } 
	  string = Expression() {sb.append(" "); sb.append(string); } 

	  ( 
	    <CC_ELSIF> {sb.append(" "); sb.append(token.image); } 
	    string = ConditionalOrExpression() {sb.append(" "); sb.append(string); }  
	    <CC_THEN> {sb.append(" "); sb.append(token.image); } 
	    string = Expression() {sb.append(" "); sb.append(string); } 
	  )* 

	  ( 
	    <CC_ELSE> {sb.append(" "); sb.append(token.image); } 
	    string = Expression()  {sb.append(" "); sb.append(string); } 
	  )*

	  <CC_END> {sb.append(" "); sb.append(token.image); } 
	)
 { 
 return sb.toString(); 
 }
}


String Assignment() :
{ String string = null; StringBuffer sb = new StringBuffer() ; }
{
  (
  (string = PrimaryExpression() ) {sb.append(string);} 
  (":" "="  ) {sb.append(" := ");} 
  (string = Expression()) {sb.append(string);} 
  )
 { 
 return sb.toString(); 
 }
}

String CaseExpression() :
{ Token start = token; Token thisToken;  String string = null; StringBuffer sb = new StringBuffer() ; }
{
 {System.err.println("CaseExpression: attempting CaseExpression() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }

  (
	thisToken = <CASE> { sb.append(thisToken.image);} 
	( string = Expression() { sb.append(" "); sb.append(string); }  )?
          ( thisToken = <WHEN> { sb.append("  "); sb.append(thisToken.image); } 
	        string = Expression() { sb.append(" "); sb.append(string); }
	     thisToken = <THEN>  { sb.append(" "); sb.append(thisToken.image); }
	        string=  Expression() { sb.append(" "); sb.append(string); } 
	   )+
	  [ thisToken = <ELSE> { sb.append(" "); sb.append(thisToken.image);} 
	        Expression() { sb.append(" "); sb.append(string); }
	  ]
	  thisToken = <END> { sb.append(" "); sb.append(thisToken.image);}
{System.err.println("CaseExpression: completed CaseExpression() starting at line " +start.beginLine+", column "+start.beginColumn+" -  \""+start.image+"\" and finishing at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }

  )
 { 
 return sb.toString(); 
 }
}

/*
LIKE ( Expression ) [ <ESCAPE> <STRINGLITERAL>
*/
String LikeExpression() :
{ Token thisToken;  String string = null; StringBuffer sb = new StringBuffer() ; }
{
  (
        string = PrimaryExpression() { sb.append(" "); sb.append(string); }
	(thisToken = <LIKE> ) { sb.append(thisToken.image);} 
	//[<LPAREN> { sb.append( "(" ;} ]
	( string = StringExpression() { sb.append(" "); sb.append(string); }  )
	//[ <RPAREN> { sb.append( ")" );} ]
	[
	<ESCAPE> { sb.append(" ESCAPE ");} 
	(  <CHARACTER_LITERAL> { sb.append(" "); sb.append(token.toString()); }  
	  | string = StringLiteral() { sb.append(" "); sb.append(string); }  
	  | thisToken = UnqualifiedID() { sb.append(" "); sb.append(thisToken.image); }  
	)
	]
  )
  ( "." string = Expression() { sb.append("."); sb.append(string); } )*
 { 
 return sb.toString(); 
 }
}

String TrimExpression() :
{ Token thisToken;  String string = null; StringBuffer sb = new StringBuffer() ; }
{
  (
	(thisToken = <TRIM> ) { sb.append(thisToken.image);} 
	<LPAREN> { sb.append("(");} 
	 [ ( <LEADING> | <TRAILING> | <BOTH> ){ sb.append(" "); sb.append(token.toString()); }  ]
	 [ string = StringExpression() { sb.append(" "); sb.append(string); } ]
	 ( <FROM>  )  { sb.append(thisToken.image);} 
	 string = StringExpression() { sb.append(" "); sb.append(string); }  
	<RPAREN> { sb.append(")");} 
  )
 { 
 return sb.toString(); 
 }
}


/*
TREAT ( Expression AS datatype)
CAST ( Expression AS datatype)
XMLCAST ( Expression AS datatype)
*/
String ObjectExpression() :
{ Token thisToken;  String string = null; StringBuffer sb = new StringBuffer() ; }
{
  (
	(thisToken = <CAST> | thisToken = <TREAT> | thisToken = <XMLCAST> ) { sb.append(thisToken.image);} 
	<LPAREN> { sb.append("(");} 
	( string = Expression() { sb.append(" "); sb.append(string); }  )
	[
	 <AT> <TIME> <ZONE> string = PrimaryExpression() { sb.append(" AT TIME ZONE "); sb.append(string); }
	]
	<AS> { sb.append(" AS ");} 
	( string = datatype() { sb.append(" "); sb.append(string); }  )
	<RPAREN> { sb.append(")");} 
  )
  ( "." Expression() )*
 { 
 {System.err.println("ObjectExpression: \""+sb.toString() + "\""); }
 return sb.toString(); 
 }
}

/*
EXTRACT ( Time Component FROM Expression)
*/
String ExtractExpression() :
{ Token thisToken;  String string = null; StringBuffer sb = new StringBuffer() ; }
{
  (
	(thisToken = <EXTRACT> ) { sb.append(thisToken.image);} 
	<LPAREN> { sb.append("(");} 
        (  thisToken = <YEAR>  
         | thisToken = <MONTH>
         | thisToken = <DAY>
         | thisToken = <HOUR>
         | thisToken = <MINUTE>
         | thisToken = <SECOND>
         | thisToken = <TIMEZONE_HOUR>
         | thisToken = <TIMEZONE_MINUTE>
         | thisToken = <TIMEZONE_REGION>
         | thisToken = <TIMEZONE_ABBR>
        )?
        { 
	      if (thisToken != null) 
              {
		sb.append(" "); sb.append(thisToken.toString()) ;
	      }
           
        }
	( <FROM> ) { sb.append(" FROM "); }
	( string = Expression() { sb.append(" "); sb.append(string); }  )
	<RPAREN> { sb.append(")");} 
  )
 { 
 {System.err.println("ExtractExpression: \""+sb.toString() + "\""); }
 return sb.toString(); 
 }
}

String ConditionalOrExpression() :
{ String string = null; StringBuffer sb = new StringBuffer() ; }
{
  (
  (string = ConditionalAndExpression() ) { sb.append(string);}
  ( (<OR>) {sb.append(" OR ");}  
    (string = ConditionalAndExpression() ) {sb.append(string);}
  )*
  )
 { 
 {System.err.println("ConditionalOrExpression: \""+sb.toString() + "\""); }
 return sb.toString(); 
 }
}

String ConditionalAndExpression() :
{ String string = null; StringBuffer sb = new StringBuffer() ; }
{
  (
   (string = EqualityExpression() ) { sb.append(string);}
   ( (<AND> ) {sb.append(" AND ");}  
     (string = EqualityExpression() ) { sb.append(string);}
   )*
  )
 { 
 {System.err.println("ConditionalAndExpression: \""+sb.toString() + "\""); }
 return sb.toString(); 
 }
}

String EqualityExpression() :
{ String string = null; StringBuffer sb = new StringBuffer() ; }
{
  //RelationalExpression() ( ( "=" | "!=" | "<>" | <IS>) RelationalExpression() )*
  (
	  (
	    (
	      string = RelationalExpression() 
	    ) {sb.append(string);} 
	  ) 
	  ( 
	   ( ("=" ) {sb.append(" = ");}
	   | ("!" "=" ) {sb.append(" != ");}
	   | ("^" "=" ) {sb.append(" ^= ");}
	   // Now unde RelationalExpression | ("<" ">" ) {sb.append(" <> ");}
	   | (<IS>) {sb.append(" IS ");}  
           )
	   (
	     (
	       string = RelationalExpression() 
	     ) {sb.append(string);} 
	   ) 
	  )*
  )
 { 
 {System.err.println("EqualityExpression: \""+sb.toString() + "\""); }
 return sb.toString(); 
 }
}

/**
 * 2006-05-23 - Matthias Hendler - added FROM
 */
String RelationalExpression() :
{ Token thisToken = null ; String string = null; StringBuffer sb = new StringBuffer() ; }
{
 (
  {System.err.println("RelationalExpression: attempting RelationalExpression() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\"  - this is just before token \""+ getToken(1).image +"\"" ); }

  //AdditiveExpression() ( ( "<" | ">" | "<=" | ">=" | [<NOT>] (<IN> | <BETWEEN> | <LIKE> | <FROM>) ) AdditiveExpression() )*
  ( 
   LOOKAHEAD(2, [ <NOT> ] <EXISTS> ) [ <NOT> ] <EXISTS>  SqlSafeSubquery() { string = "[NOT] EXISTS ... " ; }  //SQL  
   | 
    string = AdditiveExpression() 
  ) { sb.append(string); }
  ( 
   ( 
      (
	(
	    (("<" ) { sb.append("<"); } 
	     [">"  { sb.append(">"); } ] // <> 
	    )
	  | (">" ) { sb.append(">"); }
	)
	[ ("=" ) { sb.append("="); } ]
    
      )
      { sb.append(" "); } 
     | [(<NOT>) { sb.append(" NOT "); }] 
     (
	       (<IN>) { sb.append(" IN "); } 
	     | (<EXISTS> ) { sb.append(" EXISTS "); } //SQL 
	     | (<BETWEEN> ) { sb.append(" BETWEEN "); }
	     | (<LIKE> ) { sb.append(" LIKE "); }
	//@TODO SQL Breaks SqlSelectItem - is <FROM> valid here?      | (<FROM>) { sb.append(" FROM "); }
	     | (
		 (
		   (<MEMBER>) { sb.append(" MEMBER "); }
		   |
		   (<SUBMULTISET>) { sb.append(" SUBMULTISET "); }
		 )
		 [ <OF> { sb.append(" OF "); } ]
	       )
     ) 
    // MULTISET Operators 
    | ( 
       <MULTISET> { sb.append (" MULTISET " );}  
       (   <EXCEPT>  { sb.append (" EXCEPT " );}  
         | <INTERSECT>  { sb.append (" INTERSECT " );} 
	 | <UNION>  { sb.append (" UNION " ); }    
       )
       [   <DISTINCT>  { sb.append (" DISTINCT " );} 
         | <ALL>  { sb.append (" ALL " );}   
       ]
     ) 
   ) 
   (string=AdditiveExpression() ) { sb.append(string); }
   [
	<ESCAPE> { sb.append(" ESCAPE ");} 
	(  <CHARACTER_LITERAL>{ sb.append(" "); sb.append(token.toString()); }  
	  | string = StringLiteral() { sb.append(" "); sb.append(string); }  
	  | thisToken = UnqualifiedID() { sb.append(" "); sb.append(thisToken.image); }  
	)
   ]
  )*
 )
 { 
  {System.err.println("RelationalExpression: completed RelationalExpression() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
 {System.err.println("RelationalExpression: \""+sb.toString() + "\""); }
 return sb.toString(); 
 }
}

String AdditiveExpression() :
{ String string = null; StringBuffer sb = new StringBuffer() ; }
{
 (
  (string = MultiplicativeExpression() ) { sb.append(string); }
  ( 
    ( ("+" ) { sb.append(" + "); }
    | ("-" ) { sb.append(" - "); }
    | ("||" ) { sb.append(" || "); }
    ) 
    (string = MultiplicativeExpression() ) { sb.append(string); }
  )*
 )
 { 
 {System.err.println("AdditiveExpression: \""+sb.toString() + "\""); }
 return sb.toString(); 
 }
}

String StringExpression() :
{ String string = null; StringBuffer sb = new StringBuffer() ; }
{
 (
  (string = PrimaryExpression() ) { sb.append(string); }
  ( 
     ("||" ) { sb.append(" || "); }
    (string = PrimaryExpression() ) { sb.append(string); }
  )*
 )
 { 
 return sb.toString(); 
 }
}

String MultiplicativeExpression() :
{ String string = null; StringBuffer sb = new StringBuffer() ; }
{

  //UnaryExpression() ( ( <MULT> | "/" | <MOD> ) UnaryExpression() )*
 (
  (string = UnaryExpression(true) ) { sb.append(string); }
  ( 
    ( ("**"  ) { sb.append(" ** "); } //Exponentiation 
    | (<MULT>  ) { sb.append(" * "); }
    | ("/"  ) { sb.append(" / "); }
    | (<MOD>  ) { sb.append(" MOD "); }
    ) 
    (string = UnaryExpression(true) ) { sb.append(string); }
  )*
 )
 { 
 {System.err.println("MultiplicativeExpression: \""+sb.toString() + "\""); }
 return sb.toString(); 
 }
}

String UnaryExpression(boolean isUnarySign) :
{ String string = null; StringBuffer sb = new StringBuffer() ; }
{
  {System.err.println("UnaryExpression: attempting UnaryExpression() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
 (
   ( ("+" ) { sb.append(isUnarySign ? " +" : " + "); }
   | ("-" ) { sb.append(isUnarySign ? " -" : " - "); }
   ) 
   (string = UnaryExpression(false) ) { sb.append(string); }
  |
   (string = UnaryExpressionNotPlusMinus() ) { sb.append(string); }
 )
 { 
  {System.err.println("UnaryExpression: completed UnaryExpression() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
 {System.err.println("UnaryExpression: \""+sb.toString() + "\""); }
 return sb.toString(); 
 }
}

String UnaryExpressionNotPlusMinus() :
{ String string = null; StringBuffer sb = new StringBuffer() ; }
{
  {System.err.println("UnaryExpressionNotPlusMinus: attempting UnaryExpressionNotPlusMinus() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
  (
  (
    (<NOT>) {sb.append(" NOT "); } 
    |
    (<PRIOR>) {sb.append(" PRIOR "); } 
  )
  (string = UnaryExpression(false) ) { sb.append(string); }
  |
   (string = PrimaryExpression() ) { sb.append(string); }
  )
 { 
  {System.err.println("UnaryExpressionNotPlusMinus: completed UnaryExpressionNotPlusMinus() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
 {System.err.println("UnaryExpressionNotPlusMinus: \""+sb.toString() + "\""); }
 return sb.toString(); 
 }
}

/**
 * 2006-05-23 - Matthias Hendler - Added lookahead otherwise warning encountered.
 *                                 Warning arised while adding methode triggerUnit(). 
 * 2011-04-27 - SRT - Add optional NEW Keyword to cope with Object Type constructors
 */
String PrimaryExpression() :
{ Token thisToken ; String string = null; StringBuffer sb = new StringBuffer() ;
}
{
  {System.err.println("PrimaryExpression: attempting PrimaryExpression() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
  ( 
    ( // Explicitly cope with case where "NEW" is a Primary Prefix, such as in a Trigger WHEN clause  
	    (<NEW_DOT> thisToken = QualifiedID()  ) { sb.append(" NEW."); sb.append(thisToken.toString()); }  
      )
    |
    (
      LOOKAHEAD( <NEW>  PrimaryPrefix() ) // Lookahead so that we can recover and treat NEW as an identifier 
        <NEW> { sb.append(" NEW "); } (string = PrimaryPrefix() ) {sb.append(string);}  
      |       (string = PrimaryPrefix() ) {sb.append(string);}  
	  
    )
  {System.err.println("PrimaryExpression: attempting PrimarySuffix() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
    ( LOOKAHEAD(2) (string = PrimarySuffix() ) { sb.append(string); }  )*
  {System.err.println("PrimaryExpression: completed PrimarySuffix() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
  )

 { 
  {System.err.println("PrimaryExpression: completed PrimaryExpression() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
 {System.err.println("PrimaryExpression: \""+sb.toString() + "\""); }
 return sb.toString(); 
 }
}

String PrimaryPrefix() :
{ String string = null; StringBuffer sb = new StringBuffer() ; 

}
{
  {System.err.println("PrimaryPrefix: attempting PrimaryPrefix() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
(
  LOOKAHEAD(Literal()) ( string = Literal() ) { sb.append(string) ; } 
| LOOKAHEAD(MultiSetCondition()) string = MultiSetCondition() { sb.append(string) ; } 
| LOOKAHEAD(CompilationExpression()) string = CompilationExpression() //SRT 
| LOOKAHEAD(TrimExpression()) string = TrimExpression()  { sb.append(string) ; } //SRT 20110613.3
| ({System.err.println("PrimaryPrefix: attempting CaseExpression() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
 //LOOKAHEAD(CaseExpression()) string =CaseExpression()  { sb.append(string) ; }  //SRT 20110520
 string =CaseExpression()  { sb.append(string) ; }  //SRT 20110520
   {System.err.println("PrimaryPrefix: after CaseExpression() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
  )
| ({System.err.println("PrimaryPrefix: attempting xmlQuery() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
 string =xmlQuery()  { sb.append(string) ; }  
   {System.err.println("PrimaryPrefix: after xmlQuery() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
  )
| ({System.err.println("PrimaryPrefix: attempting xmlExists() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
 string =xmlExists()  { sb.append(string) ; }  
   {System.err.println("PrimaryPrefix: after xmlExists() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
  )
| ({System.err.println("PrimaryPrefix: attempting xmSerialize() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
 string =xmlSerialize()  { sb.append(string) ; }  
   {System.err.println("PrimaryPrefix: after xmlSerialize() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
  )
| LOOKAHEAD(ObjectExpression() ) ( string = ObjectExpression() ) { sb.append(string) ; } //SRT 20110604
| LOOKAHEAD(ExtractExpression() ) ( string = ExtractExpression() ) { sb.append(string) ; } 
//| LOOKAHEAD(XMLAttributes() ) ( string = XMLAttributes() ) { sb.append(string) ; } 
//| LOOKAHEAD(LikeExpression()) ( string = LikeExpression() ) { sb.append(string) ; } //SRT 20110604 
| ( string =Name() ) { sb.append(string) ; 
                      System.err.println("PrimaryPrefix: matched Name() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
                     } 
//SQL
| LOOKAHEAD(<SELECT>) (<SELECT>) {sb.append("SELECT ..."); }  skip2NextTerminator(null,";")  
| LOOKAHEAD((<LPAREN>)+ <SELECT>) (<LPAREN>) {sb.append("(SELECT ..."); }  skip2NextTerminator("(",")") <RPAREN>   
| LOOKAHEAD(<WITH>) (<WITH>) {sb.append("WITH ..."); }  skip2NextTerminator(null,";")  
| LOOKAHEAD((<LPAREN>)+ <WITH>) (<LPAREN>) {sb.append("(WITH ..."); }  skip2NextTerminator("(",")") <RPAREN>   
| ("(*)" ) {sb.append("(*)"); } //SQL @TODO make <LPAREN> and <RPAREN> Tokens    //SQL
// | LOOKAHEAD( [<LPAREN>] (<SELECT> | <WITH>) ) SqlSafeSubquery() //SQL @TODO 
|
  (
  (<LPAREN>  {sb.append("("); } )
  (string = Expression()  {sb.append(string); } )
  (
    (",") {sb.append(", "); }  
    (string = Expression() ) {sb.append(string); } 
  )* 
  (<RPAREN> {sb.append(")"); } )
  )

)
 { 
  {System.err.println("PrimaryPrefix: completed PrimaryPrefix() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
 {System.err.println("PrimaryPrefix: \""+sb.toString() + "\""); }
 return sb.toString(); 
 }
}

String PrimarySuffix() :
{ Token suffixToken = null ; String string = null ; String arguments = null; StringBuffer sb = new StringBuffer() ; 
System.err.println("PrimarySuffix: init ");
}
{
  {System.err.println("PrimarySuffix: attempting PrimarySuffix() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "
                     +"  just before \"" + getToken(1).image +"\"" 
                     ); }
  (
  (
   {System.err.println("PrimarySuffix: attempting \".*\" wildcard suffixToken at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
   suffixToken = ".*"  { sb.append(suffixToken.toString()) ; } 
  )
  |
  (
   {System.err.println("PrimarySuffix: attempting \".\" suffixToken at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
   "." ( suffixToken = <MULT> | suffixToken = QualifiedID() )  { sb.append(".");  sb.append(suffixToken.toString()) ; } 
  )
  //Bug 3535118 - Method call may include dblink 
  //String dblink = null;
  //["@" dblink = QualifiedName() {sb.append("@"); sb.append(dblink); } ]
  | //Possible dblink 
  (
   "@" suffixToken = QualifiedID() 
  ) {sb.append("@"); sb.append(suffixToken.toString()) ; }
  | //Possible Date Time Expression - Bug 3553725  
  ( <AT> {sb.append(" "); sb.append(token.image.toUpperCase());}  
          (  <LOCAL> {sb.append(" "); sb.append(token.image.toUpperCase());}
            | ( <TIME> <ZONE> {sb.append(" TIME ZONE");} ( <DBTIMEZONE> {sb.append(" "); sb.append(token.image.toUpperCase());}
	        | <SESSIONTIMEZONE> {sb.append(" "); sb.append(token.image.toUpperCase());}
	        | string = StringLiteral() {sb.append(" "); sb.append(string);}
		| string = Expression() ) {sb.append(" "); sb.append(string);}
	      )
         )   
  ) 
/*
  | //Possible XMLExists  XMLPassing Clause http://docs.oracle.com/cd/B28359_01/server.111/b28286/functions231.htm
  ( <PASSING> {sb.append(" "); sb.append(token.image.toUpperCase());}  
          //[ <BY> <VALUE> {sb.append(" BY VALUE"); } ]
	  //( string = Expression() {sb.append(" "); sb.append(string);} )
          //( <AS> {sb.append(" "); sb.append(" AS");} )
	  //( string = StringLiteral() {sb.append(" "); sb.append(string);} )
  ) 
*/
  | 
  (
      {System.err.println("PrimarySuffix: past <AT> line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
      (
	  (
      {System.err.println("PrimarySuffix: attempting (+) line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
	    ("(+)") { sb.append( "(+)" ) ; }
	  )
	  |
	  (
      {System.err.println("PrimarySuffix: attempting (*) line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
	    ("(*)") { sb.append( "(*)" ) ; }
	  )
	  |
	  ( 
	    {System.err.println("PrimarySuffix: attempting Arguments() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
            arguments = Arguments() {sb.append(arguments) ; } 
	    {System.err.println("PrimarySuffix: completed Arguments() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
          )
      )
    //SQL Add Aggregate function  
    [
  {System.err.println("PrimarySuffix: attempting KEEP Clause at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
      <KEEP>
      <LPAREN>
	      <DENSE_RANK> ( <FIRST> | <LAST> ) SqlOrderByClause()
      <RPAREN>

      {
       System.err.println("PrimarySuffix: completed KEEP Clause at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
       sb.append(" KEEP ( ... ) ") ; 
      }
    ]

    //SQL Add Analytic function  
    [
	  {System.err.println("PrimarySuffix: attempting OVER Clause at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
      <OVER> <LPAREN> 
	[ SqlQueryPartitionClause() ]
	[ SqlOrderByClause() ]
	[ SqlWindowingClause() ]
      <RPAREN>

      {sb.append(" OVER ( ...  ) ") ; 
       System.err.println("PrimarySuffix: completed OVER Clause at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
      }
    ]
  )
 )
 { 
  {System.err.println("PrimarySuffix: completed PrimarySuffix() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
 {System.err.println("PrimarySuffix: \""+sb.toString() + "\""); }
 return sb.toString(); 
 }
}

String Literal() :
{ Token literalToken = null ; String literal = null ; }
{
  (
  literalToken = NumericLiteral() {literal = literalToken.toString(); }
|
  <CHARACTER_LITERAL> {literal = token.toString(); }
|
  //<STRING_LITERAL> {literal = token.toString(); }
  literal = StringLiteral() //SRT 2010526 Cope with Q-QuotedStrings
|
  literal = BooleanLiteral()
|
  literal = NullLiteral()
|
  literal = DateTimeLiteral()
  )

 { 
 return literal; 
 }
}

String StringLiteral() :
{
Token thisToken = null;
StringBuffer literal = new StringBuffer() ; 
char startDelimiter ; 
char endDelimiter ; 
String terminator = null; 
}
{
  //Essentially unchanged
 (
  thisToken = <STRING_LITERAL> 
  { 
   literal.append(thisToken.image); 
   /*
   This might be Q-Quoted string and this might be only a partial string
   The token will only match up to the first single quote.
   The code below appends any remaining part, theh returns the complete string
   */
   if (thisToken.image.toUpperCase().startsWith("Q'")
       && thisToken.image.length() > 2
      )
   {
   // Get the first token of the string so that the delimiter can be identified

     startDelimiter= thisToken.image.charAt(2) ;
     /*
     if the start delimiter is one of [, {, <, or (, the end delimiter
     is the corresponding closing character
     */
     switch (startDelimiter)
     {
      case '<' : endDelimiter = '>' ; break ; 
      case '{' : endDelimiter = '}' ;  break ; 
      case '(' : endDelimiter = ')' ;  break ; 
      case '[' : endDelimiter = ']' ;  break ; 
      default: endDelimiter = startDelimiter ; 
     }

     terminator = new String(endDelimiter + "'");
     if (!thisToken.image.endsWith(terminator))
     {
       //Loop until we find atoken that ends with a single-quote precede by the terminator
       literal.append(readPastNextOccurrence(terminator));
     }
   }
  }
 )
 { return literal.toString(); }
}


String BooleanLiteral() :
{String literal = null ; }
{
  //Essentially unchanged
 (
  <TRUE> { literal = " TRUE " ; }
	|
  <FALSE> { literal = " FALSE " ; }
 )
 { return literal; }
}

String NullLiteral() :
{String literal = null ; }
{
  //Essentially unchanged
  (
  <NULL> { literal = " NULL " ; }
  )
 { 
  return literal; 
  }
}

String MultiSetCondition() :
{String literal = null ; }
{
  //Essentially unchanged
  (
  <A> <SET> { literal = " A SET " ; }
  |
  <EMPTY> { literal = " EMPTY " ; }
  )
 { 
  return literal; 
  }
}

/** Recognizes a numeric literal.
* This may look like token, but it isn't. Not atomic enough.
* E.g. "+1" would be valid literal, which make parsing of "i+1" impossible
* (here, we have tokens "i", "+" and "1")
*/
Token NumericLiteral() :
{ Token main = null; }
{
	(
	  //Essentially unchanged, as it previouly returned a Token 
		main=<UNSIGNED_NUMERIC_LITERAL>
	)
	{ 
	 return main; 
	}
}

/** Recognizes a labe.
* This may look like token, but it isn't. Not atomic enough.
* E.g. "+1" would be valid literal, which make parsing of "i+1" impossible
* (here, we have tokens "i", "+" and "1")
*/
String Label() :
{ 
Token labelID = null; 
StringBuffer sb = new StringBuffer(); 
}
{
	(
	  //This cannot be a token because these are valid labels '<< next_msg >>", '<<"OUTER LOOP">>'  
	"<<" labelID = UnqualifiedID() ">>" {sb.append("<<");  sb.append(labelID);  sb.append(">>");  }
	)
	{ 
	 return(sb.toString()); 
	}
}

String Name() :
{
	Token thisToken = null;
	Token separatorToken = null;
	StringBuffer sb = new StringBuffer();
}
{
  //UnqualifiedID() (LOOKAHEAD(2) ("." | "%") QualifiedID())*
  (thisToken=UnqualifiedID()) {sb.append(thisToken); }
  (
   LOOKAHEAD(2) 
    ("." {sb.append(".");} | "%" {sb.append("%");}) //QualifiedID() 
    thisToken = QualifiedID() {sb.append(thisToken);}
  )*
  {
  return(sb.toString()); 
  }
}

String QualifiedName() :
{
	Token thisToken = null;
	StringBuffer sb = new StringBuffer();
}
{
  //Essentially unchanged as it previously returned a String 
	(thisToken=UnqualifiedID()) {sb.append(thisToken); }
	( ("." thisToken=QualifiedID()) { sb.append("."); sb.append(thisToken); } )*
	{ 
	 return(sb.toString()); 
	}
}

String Arguments() :
{
	Token t = token ;
	String argumentList = null;
	StringBuffer sb = new StringBuffer();
}
{
  {System.err.println("Arguments: attempting Arguments() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
  }
  //"(*)" { sb.append( token.image ) ; }  
  //|
  (
	  
          //( LOOKAHEAD(2, <LPAREN> ( <SELECT> | <WITH> ) ) SqlSafeSubquery() )
          (
	  //<LPAREN> [ ArgumentList() ] <RPAREN>
	  (<LPAREN>) { sb.append("("); 
	  System.err.println("Arguments: found LPAREN at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
	  System.out.println("Arguments: found LPAREN at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
	  }  
	  try { 
	  [ 
	    { System.err.println("Arguments: trying ...  at line "
			      +token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
            }

	    ( LOOKAHEAD(SqlSubquery()) //LOOKAHEAD(1, ( <SELECT> | <WITH> ) ) 
		       { System.err.println( "Arguments: SqlSubquery parsing attempt in " + inputPath ); }
		       ( SqlSubquery() )
		       {System.err.println("Arguments: "
					      + "completed SqlSubquery Argument at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\";"
					      + " started SqlSubquery()  Argumentat line "+t.beginLine+", column "+t.beginColumn+" - \""+t.image+"\" "
					    ); 
		       }
	    )
	    |
	    { System.err.println("Arguments: Looking for *) at line "
			      +token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
            }

	    LOOKAHEAD(2, <MULT> <RPAREN> ) <MULT> { sb.append("*") ; 
						    System.err.println("Arguments: found MULT RPAREN  at line "
								      +token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
						    System.out.println("Arguments: found MULT RPAREN  at line "
								      +token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
						   } 
	   |
	    { System.err.println("Arguments: looking for standard ArgumentList()  at line "
			      +token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
            }
	   (argumentList = ArgumentList()) { sb.append(argumentList); } 
	    { System.err.println("Arguments: found standard ArgumentList()  at line "
			      +token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
            }
	  ] 
	  (<RPAREN>) { sb.append(")"); }  
	  }
	  catch (ParseException e) {
	    System.err.println( " Arguments parsing error in " + inputPath ); 
	    e.printStackTrace(System.err);  // print the error message
	    System.err.println("Arguments: recovery starting: "
			       + "rewinding to line "+t.beginLine+", column "+t.beginColumn+" - \""+t.image+"\" "
			       + "; currently at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "
			      ); 
	    argumentList = parenthesesContents(t); 
	    System.err.println("Arguments: recovery completed at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
	  }
          )
  )
 { 
  System.err.println("Arguments: completed Arguments() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
  System.out.println("Arguments: completed Arguments() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); 
 return sb.toString(); 
 }
}

String ArgumentList() :
{
	String argument = null;
	Token thisToken = null;
	String expression = null;
	String literal = null;
	StringBuffer sb = new StringBuffer();
}
{
  {System.err.println("ArgumentList: attempting ArgumentList() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
  {System.out.println("ArgumentList: attempting ArgumentList() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
  //Argument() ("," token=Argument())*
  (argument = Argument()) { sb.append(argument); } 
    [ <PASSING> expression = Expression() <AS> literal = Literal() { sb.append("PASSING "); sb.append(expression); sb.append(" AS "); sb.append(literal); } ]
  (("," ) { sb.append(", "); }  (argument = Argument()) {sb.append(argument); } 
    [ <AS> literal = Literal() { sb.append(" AS "); sb.append(literal); } ]
  )*
 { 
  {System.err.println("ArgumentList: completed ArgumentList() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
  {System.out.println("ArgumentList: completed ArgumentList() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
 return sb.toString(); 
 }
}

String Argument() :
{
	Token thisToken = null;
	String string = null;
	StringBuffer sb = new StringBuffer();
}
{
  {System.err.println("Argument: attempting Argument() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
  {System.out.println("Argument: attempting Argument() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
	//[LOOKAHEAD(2) UnqualifiedID() "=>"] Expression()
	[LOOKAHEAD(2) ( thisToken=<MULT> | thisToken=UnqualifiedID() ) {sb.append(thisToken); } ("=>" | <AS> ) { sb.append(" "); sb.append(token.image.toUpperCase()); sb.append(" "); } ] 
        (string = ConditionalOrExpression() ) {sb.append(string); } 
        //(string = parenthesesContents() ) {sb.append(string); } 
	// Cope with XMLATTRIBUTES and XMLNAMESPACES arguments (Expression AS QuotedLiteral)
	[
	 <AS> (<IDENTIFIER> | <QUOTED_LITERAL>) { sb.append(" AS "); sb.append(token.image); sb.append(" "); }
        ]

	//Allow Using CharacterSet suffix clause  
	[
	   ( <USING>  )  { sb.append(" "); sb.append(token.image.toUpperCase()); } 
	   ( <CHAR_CS> | <NCHAR_CS>  )  { sb.append(" "); sb.append(token.image.toUpperCase()); } 
	]
 { 
 {System.err.println("Argument: \""+sb.toString() + "\""); }
 {System.out.println("Argument: \""+sb.toString() + "\""); }
  {System.err.println("Argument: completed Argument() at line "+token.beginLine+", column "+token.beginColumn+" - \""+token.image+"\" "); }
 return sb.toString(); 
 }
}



// ============================================================================
// D E C L A R A T I O N S
// ============================================================================

void VariableOrConstantDeclaration(boolean isPackageLevel) throws org.xml.sax.SAXException :
{ Token name=null;
	String type;
	Hashtable tags = null;
	String elementName = "VARIABLE";
	String defaultValue = null;
	Hashtable variableAttributes = new Hashtable();
}
{
	name=ID() [LOOKAHEAD(2) <CONSTANT> {elementName = "CONSTANT";}] type=datatype()
	[[<NOT>] <NULL>]
	[
	//SRT 20110427 (":=" | <_DEFAULT>) Expression()
	(":" "=" | <_DEFAULT>) (defaultValue = Expression() )
	] ";"
	{
		// element generated only on the package level
		if (m_out != null && isPackageLevel)
		{
			if (null != defaultValue) variableAttributes.put("DEFAULT"
			                                                , (defaultValue.startsWith("'") 
			                                                   ||defaultValue.toUpperCase().startsWith("Q'") 
									  ) // Literal
									  ?HTMLEscaper.escape(defaultValue) //Escape Literal
									  :purifyIdentifier(defaultValue)
			                                                );
			tags = processMemberComment(name, elementName, name.toString(),variableAttributes);
			m_out.pushAttribute("TYPE", purifyIdentifier(type));
			m_out.startElement("RETURN");
			m_out.endElement("RETURN");
			m_out.endElement(elementName);
		}
	}
}

void DatatypeDeclaration() : {} { <IDENTIFIER> }

void Pragma(boolean isPackageLevel) throws org.xml.sax.SAXException :
{ Token start,name = null,functionName,exceptionName,errorNumber; Hashtable tags = null; 
  String string = null ; 
}
{
	start=<PRAGMA>
	(
		name=<SERIALLY_REUSABLE>
		|
		name=<AUTONOMOUS_TRANSACTION>
		|
		name=<TIMESTAMP> <LPAREN> StringLiteral() <RPAREN>
		|
		name=<RESTRICT_REFERENCES> <LPAREN> (functionName=ID() /*| <_DEFAULT>*/)
		("," (ID() | StringLiteral() /* 20110526 <STRING_LITERAL> */ ) )+	<RPAREN>
		|
		name=<EXCEPTION_INIT> <LPAREN> exceptionName=UnqualifiedID()  "," ["+"|"-"] errorNumber=NumericLiteral() <RPAREN>
		|
		name=<INTERFACE> <LPAREN> <IDENTIFIER> "," ID() [ "," NumericLiteral() ] <RPAREN>
		| //SRT 20110531 
		string=QualifiedName() <LPAREN> readPastNextOccurrence(")") 
	)
	";"
	{
		// element generated only on the package level
		if (m_out != null && isPackageLevel)
		{
			tags = processMemberComment(start, start.toString().toUpperCase()
			, (null != name) ? name.toString() : string
			);
			m_out.endElement("PRAGMA");
		}
	}
}

void ExceptionDeclaration(boolean isPackageLevel) throws org.xml.sax.SAXException :
{ Token exception_name; Hashtable tags = null; }
{
	exception_name=ID() <EXCEPTION> ";"
	{
		// element generated only on the package level
		if (m_out != null && isPackageLevel)
		{
			tags = processMemberComment(exception_name, "EXCEPTION", exception_name.toString());
			m_out.endElement("EXCEPTION");
		}
	}
}

void ParallelClause() throws org.xml.sax.SAXException :
{
}
{
    (
	    ( <LPAREN> <PARTITION> ID()  <BY> 
	       (<ANY> 
	        |
	        ( (<HASH> | <RANGE> ) <LPAREN> ID() ( "," ID() )* <RPAREN> )
               )
	    <RPAREN>  
	    )
    )
    [ ( <ORDER> | <CLUSTER> ) <BY> <LPAREN> ID() ( "," ID() )*  <RPAREN> ] 

}

